// Class: ReadBDTs
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTs
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.22/01       [398849]
Creator        : tasheng
Date           : Mon May 16 19:39:48 2022
Host           : Linux GRENDEL01.MIT.EDU 3.10.0-957.21.3.el7.x86_64 #1 SMP Tue Jun 18 16:35:19 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/tasheng/bmva_trk5/TMVA/Bs/train
Training events: 10718
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "5.0%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "30" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
BaggedSampleFraction: "5.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "5.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 10
Btrk1Pt                       Btrk1Pt                       Btrk1Pt                       Btrk1Pt                                                         'F'    [0.502320587635,18.0151157379]
Btrk2Pt                       Btrk2Pt                       Btrk2Pt                       Btrk2Pt                                                         'F'    [0.502207756042,17.6688995361]
abs(Btrk1Dz1/Btrk1DzError1)   Trk1DCAz                      Trk1DCAz                      Trk1DCAz                                                        'F'    [0.000148123959661,9772.39941406]
abs(Btrk2Dz1/Btrk2DzError1)   Trk2DCAz                      Trk2DCAz                      Trk2DCAz                                                        'F'    [6.14790187683e-05,8440.57421875]
abs(Btrk1Dxy1/Btrk1DxyError1) Trk1DCAxy                     Trk1DCAxy                     Trk1DCAxy                                                       'F'    [0.000712597102392,128.348449707]
abs(Btrk2Dxy1/Btrk2DxyError1) Trk2DCAxy                     Trk2DCAxy                     Trk2DCAxy                                                       'F'    [3.30562070303e-05,126.480110168]
abs(Btktkmass-1.019455)       MassDis                       MassDis                       MassDis                                                         'F'    [1.94473273041e-07,0.0149943390861]
BsvpvDistance/BsvpvDisErr     dls                           dls                           dls                                                             'F'    [2.00072932243,6848.19677734]
Balpha                        Balpha                        Balpha                        Balpha                                                          'F'    [5.5780117691e-05,3.13259243965]
Bchi2cl                       Bchi2cl                       Bchi2cl                       Bchi2cl                                                         'F'    [0.0501575283706,0.999979019165]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDTsNode

#ifndef BDTsNode__def
#define BDTsNode__def

class BDTsNode {

public:

   // constructor of an essentially "empty" node floating in space
   BDTsNode ( BDTsNode* left,BDTsNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTsNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTsNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTsNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTsNode*   fLeft;     // pointer to the left daughter node
   BDTsNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDTsNode::~BDTsNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDTsNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] >= fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDTsNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTs : public IClassifierReader {

 public:

   // constructor
   ReadBDTs( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDTs" ),
        fNvars( 10 )
   {
      // the training input variables
      const char* inputVars[] = { "Btrk1Pt", "Btrk2Pt", "abs(Btrk1Dz1/Btrk1DzError1)", "abs(Btrk2Dz1/Btrk2DzError1)", "abs(Btrk1Dxy1/Btrk1DxyError1)", "abs(Btrk2Dxy1/Btrk2DxyError1)", "abs(Btktkmass-1.019455)", "BsvpvDistance/BsvpvDisErr", "Balpha", "Bchi2cl" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTs() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[10];
   double fVmax[10];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[10];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTsNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTs::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTsNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTsNode*)current->GetRight();
         else current=(BDTsNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDTs::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(1.02576032081296);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.785351, 1, 1, 0.948274,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.263356,-99) , 
6, 0.00918195, 1, 0, 0.808036,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.819306,-99) , 
NN(
0, 
0, 
-1, 0.00332298, 1, -1, 0.121862,-99) , 
5, 4.1372, 0, 0, 0.206896,-99) , 
1, 2.15192, 0, 0, 0.47469,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.735343);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.00482533, 1, 1, 0.857417,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.747057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.3431,-99) , 
5, 2.41386, 0, 0, 0.500304,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.144424,-99) , 
6, 0.00433474, 1, 0, 0.297487,-99) , 
1, 2.58114, 0, 0, 0.51421,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.834064);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.234207, 0, 1, 0.919531,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.822484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.287211,-99) , 
0, 4.89683, 0, 0, 0.362225,-99) , 
6, 0.00482794, 1, 0, 0.640138,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.118376,-99) , 
0, 1.05815, 0, 0, 0.480695,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.634714);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.61993, 0, 1, 0.940761,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486279,-99) , 
6, 0.00918955, 1, 0, 0.831747,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.801938,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.386036,-99) , 
6, 0.00137142, 1, 0, 0.498411,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.190803,-99) , 
6, 0.00532085, 1, 0, 0.341158,-99) , 
0, 2.1314, 0, 0, 0.548,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.516905);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.12787, 0, 1, 0.803264,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42496,-99) , 
6, 0.00869932, 1, 0, 0.69042,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.25628,-99) , 
0, 1.05557, 0, 0, 0.56493,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.633946);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.53438, 0, 1, 0.843067,-99) , 
NN(
NN(
0, 
0, 
-1, 0.418344, 0, 1, 0.748647,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.268905,-99) , 
5, 2.41386, 0, 0, 0.396249,-99) , 
1, 2.11698, 0, 0, 0.582064,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.733882);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.15888, 0, 1, 0.935854,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.743719,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.301985,-99) , 
6, 0.00143156, 0, 0, 0.57613,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.273419,-99) , 
1, 1.06303, 0, 0, 0.429438,-99) , 
0, 2.04485, 0, 0, 0.638026,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.576162);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.203336, 0, 1, 0.829519,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.798413,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491757,-99) , 
0, 4.07473, 1, 0, 0.67852,-99) , 
NN(
0, 
0, 
-1, 0.509777, 0, -1, 0.290623,-99) , 
4, 3.17104, 0, 0, 0.410272,-99) , 
6, 0.00483759, 1, 0, 0.60102,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.418093);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.19833, 0, 1, 0.816134,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520431,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482933,-99) , 
5, 18.0819, 0, 0, 0.502112,-99) , 
4, 12.4224, 1, 0, 0.725649,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.808801,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.383841,-99) , 
6, 0.00406724, 1, 0, 0.502315,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.308315,-99) , 
6, 0.0014452, 0, 0, 0.434973,-99) , 
0, 2.12253, 0, 0, 0.54585,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.491251);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.00677148, 1, 1, 0.962309,-99) , 
NN(
NN(
0, 
0, 
-1, 1.94896, 0, 1, 0.735652,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.863067,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.394049,-99) , 
4, 1.58888, 0, 0, 0.487305,-99) , 
4, 2.90549, 0, 0, 0.576752,-99) , 
0, 4.39123, 0, 0, 0.635545,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.511267);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.25761, 0, 1, 0.807114,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.383389,-99) , 
8, 0.100133, 1, 0, 0.70669,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.343473,-99) , 
6, 0.00967459, 1, 0, 0.615407,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.386607);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.16207, 0, 1, 0.690045,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.661233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.315552,-99) , 
5, 2.68047, 0, 0, 0.448344,-99) , 
6, 0.0067729, 1, 0, 0.592976,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.435507);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.805947,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479496,-99) , 
6, 0.0081172, 0, 0, 0.649673,-99) , 
6, 0.00483686, 1, 0, 0.779808,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574371,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.357088,-99) , 
0, 1.26948, 0, 0, 0.412692,-99) , 
1, 1.60201, 0, 0, 0.58788,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.286715);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.884826,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493334,-99) , 
4, 10.8824, 1, 0, 0.795377,-99) , 
NN(
0, 
0, 
-1, 3.83442, 0, 1, 0.599315,-99) , 
9, 0.632462, 0, 0, 0.676821,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439894,-99) , 
6, 0.0087059, 1, 0, 0.599524,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.529643);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.00434219, 1, 1, 0.769682,-99) , 
NN(
NN(
0, 
0, 
-1, 1.79754, 0, 1, 0.802485,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.77428,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.307662,-99) , 
0, 3.82182, 0, 0, 0.356339,-99) , 
9, 0.662965, 0, 0, 0.488221,-99) , 
4, 3.27887, 0, 0, 0.572706,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.420909);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.0077386, 1, 1, 0.795009,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.853112,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429527,-99) , 
6, 0.00242431, 1, 0, 0.533737,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.272528,-99) , 
5, 10.6045, 1, 0, 0.476234,-99) , 
0, 2.18475, 0, 0, 0.569193,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.364427);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.749189,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467102,-99) , 
1, 2.05509, 1, 0, 0.676789,-99) , 
1, 3.69341, 0, 0, 0.717826,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60587,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437804,-99) , 
6, 0.0104775, 1, 0, 0.506692,-99) , 
6, 0.00676631, 1, 0, 0.63749,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.448581);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 7.30944, 1, 1, 0.830844,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.691728,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.365577,-99) , 
6, 0.000932334, 1, 0, 0.528191,-99) , 
6, 0.00144852, 0, 0, 0.745038,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.809531,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.3952,-99) , 
6, 0.0024372, 1, 0, 0.482559,-99) , 
1, 1.60974, 0, 0, 0.603622,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.330557);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.718176,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455098,-99) , 
7, 8.95645, 0, 0, 0.590865,-99) , 
NN(
0, 
0, 
-1, 0.0019126, 0, -1, 0.316473,-99) , 
5, 14.9688, 1, 0, 0.551016,-99) , 
7, 222.846, 0, 0, 0.573608,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.414177);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.417416, 0, 1, 0.8691,-99) , 
NN(
NN(
0, 
0, 
-1, 1.3777, 0, 1, 0.652926,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600187,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.212463,-99) , 
1, 4.15969, 0, 0, 0.398419,-99) , 
0, 3.58953, 1, 0, 0.58184,-99) , 
5, 8.16004, 0, 0, 0.62497,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.346372);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.655712,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476658,-99) , 
1, 1.08552, 0, 0, 0.564823,-99) , 
0, 2.16617, 0, 0, 0.618559,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.665971,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.377638,-99) , 
9, 0.662877, 1, 0, 0.527333,-99) , 
NN(
0, 
0, 
-1, 0.723081, 0, -1, 0.235917,-99) , 
4, 3.16121, 0, 0, 0.327421,-99) , 
0, 3.72414, 1, 0, 0.527759,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.296793);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00336181, 1, 1, 0.972665,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586931,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447915,-99) , 
1, 3.94892, 1, 0, 0.524856,-99) , 
6, 0.00579927, 1, 0, 0.692588,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505692,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.301385,-99) , 
1, 1.1261, 1, 0, 0.409308,-99) , 
1, 1.57022, 0, 0, 0.516935,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.361805);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.695689,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.395089,-99) , 
6, 0.00144747, 0, 0, 0.604581,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.275992,-99) , 
1, 7.53092, 1, 0, 0.56026,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.330783,-99) , 
0, 1.03948, 0, 0, 0.478757,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.359619);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.5784, 0, 1, 0.694613,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.804314,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.405974,-99) , 
5, 4.08951, 0, 0, 0.480082,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.224519,-99) , 
1, 6.03985, 1, 0, 0.4308,-99) , 
6, 0.00435356, 1, 0, 0.522653,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.418232);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.01262, 0, 1, 0.850371,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.7008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443934,-99) , 
5, 2.60968, 1, 0, 0.569479,-99) , 
9, 0.608639, 1, 0, 0.6637,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593097,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.277676,-99) , 
1, 2.14545, 0, 0, 0.35466,-99) , 
9, 0.32606, 0, 0, 0.549293,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.36047);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.68692,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485265,-99) , 
0, 1.16058, 0, 0, 0.604431,-99) , 
0, 5.58857, 0, 0, 0.63285,-99) , 
NN(
0, 
0, 
-1, 0.00142268, 0, -1, 0.223226,-99) , 
4, 13.6922, 1, 0, 0.544049,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.501191);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.48358, 0, 1, 0.847214,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.756894,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400589,-99) , 
9, 0.389849, 0, 0, 0.610434,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528265,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.230609,-99) , 
9, 0.693925, 1, 0, 0.371321,-99) , 
6, 0.00601427, 0, 0, 0.521239,-99) , 
6, 0.00386138, 1, 0, 0.62376,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.399944);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.601326, 1, 1, 0.932173,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.769814,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431562,-99) , 
5, 2.05207, 0, 0, 0.53261,-99) , 
5, 10.6013, 0, 0, 0.56881,-99) , 
1, 4.37856, 0, 0, 0.611899,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.333682);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.754734,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484927,-99) , 
7, 30.9741, 1, 0, 0.648381,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44379,-99) , 
8, 0.101191, 1, 0, 0.612719,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.222838,-99) , 
9, 0.111429, 0, 0, 0.558478,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.412932);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.53906, 0, 1, 0.707522,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.777906,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.346584,-99) , 
9, 0.106307, 0, 0, 0.557526,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528846,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.224788,-99) , 
9, 0.228203, 0, 0, 0.384057,-99) , 
9, 0.174587, 1, 0, 0.462646,-99) , 
9, 0.325881, 0, 0, 0.610808,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.216197);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.6581,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490792,-99) , 
9, 0.662739, 0, 0, 0.53268,-99) , 
5, 7.21831, 0, 0, 0.582922,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.356023,-99) , 
6, 0.0101582, 1, 0, 0.530764,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.493231);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.676625,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.320672,-99) , 
4, 9.6133, 1, 0, 0.627334,-99) , 
4, 16.5617, 0, 0, 0.652836,-99) , 
0, 4.45682, 0, 0, 0.686624,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.523468);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.59, 0, 1, 0.876274,-99) , 
NN(
NN(
0, 
0, 
-1, 0.79818, 0, 1, 0.662869,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.850696,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.297341,-99) , 
4, 1.91965, 0, 0, 0.401364,-99) , 
9, 0.417865, 1, 0, 0.503295,-99) , 
5, 3.09568, 0, 0, 0.581414,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.263328);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.00821534, 1, 1, 0.695664,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446761,-99) , 
0, 1.06983, 0, 0, 0.578642,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.375684);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.905987, 1, 1, 0.765212,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.70797,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.295652,-99) , 
6, 0.000937683, 0, 0, 0.564551,-99) , 
9, 0.417809, 0, 0, 0.689324,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481536,-99) , 
6, 0.00966515, 1, 0, 0.630481,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.260378);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.925958, 1, 1, 0.712759,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.760819,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446078,-99) , 
1, 4.24483, 0, 0, 0.485475,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.176965,-99) , 
9, 0.795248, 1, 0, 0.446633,-99) , 
9, 0.846693, 0, 0, 0.490546,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.349086);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.821423,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436927,-99) , 
1, 3.29015, 1, 0, 0.637042,-99) , 
0, 5.67408, 0, 0, 0.681255,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552446,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.288244,-99) , 
0, 1.10394, 1, 0, 0.428467,-99) , 
1, 1.56635, 0, 0, 0.524178,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.379666);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.325912, 0, 1, 0.746595,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.330732,-99) , 
1, 6.63795, 1, 0, 0.676578,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.382497,-99) , 
0, 1.0702, 0, 0, 0.543902,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.295024);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.968147,-99) , 
NN(
NN(
0, 
0, 
-1, 1.32171, 0, 1, 0.768144,-99) , 
NN(
0, 
0, 
-1, 0.883204, 0, -1, 0.408714,-99) , 
6, 0.00193492, 1, 0, 0.454977,-99) , 
4, 13.6922, 0, 0, 0.497477,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.259535);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0.78174, 1, 1, 0.652207,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624245,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460253,-99) , 
4, 3.86805, 0, 0, 0.505919,-99) , 
9, 0.60169, 0, 0, 0.568552,-99) , 
0, 5.33371, 0, 0, 0.596234,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.322097);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.42341, 0, 1, 0.644904,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603409,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.161129,-99) , 
9, 0.694085, 1, 0, 0.37323,-99) , 
1, 6.33172, 1, 0, 0.608714,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.229755);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.966015,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.903403,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52258,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.293063,-99) , 
0, 3.32629, 1, 0, 0.476852,-99) , 
1, 4.64711, 0, 0, 0.510097,-99) , 
9, 0.907445, 0, 0, 0.542224,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.293978);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00677245, 1, 1, 0.643989,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559645,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.27385,-99) , 
9, 0.695197, 0, 0, 0.438255,-99) , 
9, 0.57013, 1, 0, 0.535178,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.317135,-99) , 
9, 0.1117, 0, 0, 0.50626,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.36864);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.86331,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453803,-99) , 
8, 0.100525, 1, 0, 0.778215,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.791307,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389099,-99) , 
9, 0.884434, 0, 0, 0.509194,-99) , 
9, 0.724224, 1, 0, 0.676582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.405601,-99) , 
0, 1.07444, 0, 0, 0.550928,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.345765);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 3.27587, 0, 1, 0.611324,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.12134,-99) , 
4, 11.9647, 1, 0, 0.554799,-99) , 
4, 15.4668, 0, 0, 0.584838,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.362873);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 6.81301, 1, 1, 0.829266,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59126,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.276774,-99) , 
6, 0.000376562, 0, 0, 0.507473,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5538,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.297038,-99) , 
0, 1.9445, 0, 0, 0.340635,-99) , 
6, 0.00386394, 1, 0, 0.405224,-99) , 
0, 3.89189, 0, 0, 0.444952,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.416593);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.78807,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499819,-99) , 
9, 0.816029, 1, 0, 0.710938,-99) , 
NN(
0, 
0, 
-1, 0.00337942, 1, -1, 0.318547,-99) , 
4, 0.796832, 0, 0, 0.541731,-99) , 
NN(
0, 
0, 
-1, 4.24007, 1, -1, 0.309963,-99) , 
4, 12.4215, 1, 0, 0.506579,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.320522);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.817883,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.362339,-99) , 
6, 0.00154854, 0, 0, 0.615039,-99) , 
6, 0.000872715, 1, 0, 0.710296,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.703304,-99) , 
NN(
0, 
0, 
-1, 0.326038, 0, -1, 0.422071,-99) , 
0, 3.912, 0, 0, 0.463703,-99) , 
6, 0.00386614, 1, 0, 0.533709,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.378179);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.31481, 0, 1, 0.766552,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.65544,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.224185,-99) , 
6, 0.000233948, 0, 0, 0.596861,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.348698,-99) , 
6, 0.00724198, 1, 0, 0.490666,-99) , 
9, 0.20358, 1, 0, 0.537405,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.266081);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.839141,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.308713,-99) , 
9, 0.797196, 1, 0, 0.526004,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.312401,-99) , 
8, 0.100773, 1, 0, 0.482609,-99) , 
9, 0.907882, 0, 0, 0.505496,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.36026);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.77912,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389786,-99) , 
0, 4.79404, 1, 0, 0.698532,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489659,-99) , 
9, 0.326167, 0, 0, 0.630003,-99) , 
NN(
NN(
0, 
0, 
-1, 0.000406774, 0, 1, 0.63274,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573956,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.275648,-99) , 
5, 3.09559, 0, 0, 0.335169,-99) , 
6, 0.00140124, 1, 0, 0.414773,-99) , 
6, 0.00483263, 0, 0, 0.521008,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.333051);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.946264,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448992,-99) , 
5, 5.52218, 0, 0, 0.506409,-99) , 
NN(
0, 
0, 
-1, 2.23852, 1, -1, 0.317238,-99) , 
9, 0.29564, 0, 0, 0.429675,-99) , 
0, 3.89189, 0, 0, 0.476348,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.306202);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.939789,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579321,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.20457,-99) , 
1, 3.62824, 1, 0, 0.545499,-99) , 
0, 3.55535, 0, 0, 0.586468,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.207887,-99) , 
1, 7.70689, 1, 0, 0.55233,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.394412);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.601667, 0, 1, 0.71724,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.302478,-99) , 
1, 6.54556, 1, 0, 0.653674,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.350449,-99) , 
1, 1.03022, 0, 0, 0.528761,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.346033);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.877115,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.62082,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.37263,-99) , 
4, 11.6008, 1, 0, 0.574806,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.245458,-99) , 
9, 0.851768, 1, 0, 0.509861,-99) , 
9, 0.938419, 0, 0, 0.539154,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.518628);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.780925,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.327932,-99) , 
4, 13.1114, 1, 0, 0.627187,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.628115,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.265568,-99) , 
7, 6.34569, 0, 0, 0.35624,-99) , 
7, 8.73293, 0, 0, 0.481421,-99) , 
7, 211.732, 0, 0, 0.507366,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.281431);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.742477,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448315,-99) , 
6, 0.00422689, 1, 0, 0.51394,-99) , 
NN(
0, 
0, 
-1, 3.53011, 1, -1, 0.220483,-99) , 
6, 0.000483669, 0, 0, 0.478251,-99) , 
4, 15.4661, 0, 0, 0.505935,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.57973);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.25404, 0, 1, 0.76874,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.348031,-99) , 
9, 0.234595, 0, 0, 0.617841,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.844402,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.329453,-99) , 
9, 0.325855, 0, 0, 0.566707,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.718063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0921333,-99) , 
0, 1.56732, 1, 0, 0.261315,-99) , 
0, 2.13115, 0, 0, 0.367159,-99) , 
5, 3.53358, 1, 0, 0.525175,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.329412);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.810967,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.67437,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.376224,-99) , 
9, 0.785244, 1, 0, 0.565001,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378521,-99) , 
6, 0.00870647, 1, 0, 0.502524,-99) , 
4, 10.2699, 0, 0, 0.529707,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.280016);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.52312, 0, 1, 0.714828,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.689425,-99) , 
NN(
0, 
0, 
-1, 0.383878, 0, -1, 0.400453,-99) , 
9, 0.203873, 1, 0, 0.451908,-99) , 
6, 0.00338674, 1, 0, 0.507283,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.478068);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.980511,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.7185,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396009,-99) , 
1, 3.71537, 1, 0, 0.614888,-99) , 
1, 4.31042, 0, 0, 0.749823,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.79745,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.240536,-99) , 
6, 0.00144213, 0, 0, 0.599333,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.34429,-99) , 
4, 2.00612, 0, 0, 0.421297,-99) , 
0, 2.09081, 0, 0, 0.515322,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.260511);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.909846,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.839653,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.710864,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459572,-99) , 
5, 4.08126, 0, 0, 0.505693,-99) , 
6, 0.00144852, 1, 0, 0.538872,-99) , 
1, 4.36293, 0, 0, 0.573475,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.289289);
  fForest.push_back( 
NN(
0, 
0, 
-1, 2.64587, 0, 1, 0.64074,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.544126);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.52857, 0, 1, 0.915163,-99) , 
NN(
NN(
0, 
0, 
-1, 0.191564, 0, 1, 0.657284,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.893697,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.250292,-99) , 
0, 2.18093, 0, 0, 0.327235,-99) , 
9, 0.448653, 1, 0, 0.481584,-99) , 
4, 4.14195, 0, 0, 0.551998,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.252802);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.914044,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.730721,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556533,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.286447,-99) , 
5, 3.55405, 1, 0, 0.487415,-99) , 
5, 12.2412, 0, 0, 0.500659,-99) , 
9, 0.938299, 0, 0, 0.527013,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.488169);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.80162, 1, 1, 0.771422,-99) , 
NN(
NN(
0, 
0, 
-1, 0.237826, 0, 1, 0.721595,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588307,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.267271,-99) , 
5, 2.07269, 0, 0, 0.335006,-99) , 
1, 2.17576, 0, 0, 0.398497,-99) , 
9, 0.632185, 0, 0, 0.51688,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.299547);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.795776,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.654635,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43687,-99) , 
6, 0.00931534, 1, 0, 0.572771,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.278867,-99) , 
9, 0.436926, 0, 0, 0.400851,-99) , 
6, 0.00241845, 0, 0, 0.529966,-99) , 
9, 0.90802, 0, 0, 0.557635,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.316542);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.822988,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.296385,-99) , 
6, 0.00387222, 0, 0, 0.68122,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51531,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.345557,-99) , 
5, 1.1858, 0, 0, 0.413981,-99) , 
5, 4.08301, 0, 0, 0.456125,-99) , 
1, 4.38302, 0, 0, 0.481588,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.33324);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.721789,-99) , 
NN(
NN(
0, 
0, 
-1, 0.000844538, 1, 1, 0.606286,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.279707,-99) , 
6, 0.0065355, 1, 0, 0.515145,-99) , 
6, 0.0096536, 0, 0, 0.57098,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.261169);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.297711,-99) , 
6, 0.00233133, 0, 0, 0.515516,-99) , 
6, 0.000967864, 1, 0, 0.543843,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.175494,-99) , 
8, 0.80846, 1, 0, 0.503197,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.334704);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587177,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.27314,-99) , 
6, 0.00145124, 0, 0, 0.51984,-99) , 
NN(
0, 
0, 
-1, 0.098187, 0, -1, 0.2631,-99) , 
9, 0.16479, 0, 0, 0.463955,-99) , 
9, 0.938567, 0, 0, 0.491254,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.389099);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.629489,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.339811,-99) , 
9, 0.882368, 1, 0, 0.516006,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519446,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.301501,-99) , 
6, 0.00242022, 1, 0, 0.331562,-99) , 
9, 0.479109, 0, 0, 0.409909,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0893006,-99) , 
1, 7.76335, 1, 0, 0.377665,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.255965);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.756523,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.649161,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481878,-99) , 
1, 2.79625, 1, 0, 0.601968,-99) , 
NN(
0, 
0, 
-1, 2.74903, 1, -1, 0.391011,-99) , 
9, 0.839788, 0, 0, 0.437032,-99) , 
9, 0.172697, 1, 0, 0.470912,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.234155);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.795741,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630566,-99) , 
NN(
0, 
0, 
-1, 3.78028, 1, -1, 0.410796,-99) , 
1, 3.82479, 0, 0, 0.437509,-99) , 
9, 0.877459, 0, 0, 0.474401,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.342085);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.45751, 0, 1, 0.62662,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.642254,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.167254,-99) , 
5, 14.4358, 1, 0, 0.559008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.286454,-99) , 
6, 0.0056146, 1, 0, 0.462637,-99) , 
6, 0.00725495, 0, 0, 0.526666,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.276818);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.55023, 0, 1, 0.63486,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.688346,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461768,-99) , 
5, 1.82719, 0, 0, 0.538881,-99) , 
NN(
0, 
0, 
-1, 0.252451, 0, -1, 0.316034,-99) , 
9, 0.200535, 1, 0, 0.430996,-99) , 
9, 0.325827, 0, 0, 0.548677,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.273224);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.846611,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565665,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.235444,-99) , 
0, 4.81506, 1, 0, 0.523092,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.332387,-99) , 
6, 0.00773911, 1, 0, 0.44574,-99) , 
9, 0.938704, 0, 0, 0.46549,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.285251);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.710008,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576056,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.268202,-99) , 
5, 5.47731, 1, 0, 0.496248,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.349498,-99) , 
0, 1.09155, 0, 0, 0.420642,-99) , 
4, 15.4528, 0, 0, 0.439272,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.277407);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00426563, 1, 1, 0.670079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.290168,-99) , 
5, 14.133, 1, 0, 0.612954,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545948,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.211752,-99) , 
6, 0.00576623, 0, 0, 0.341712,-99) , 
0, 1.63218, 1, 0, 0.446805,-99) , 
9, 0.632331, 0, 0, 0.506485,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.263115);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.869093,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.693963,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466745,-99) , 
1, 2.89117, 0, 0, 0.496866,-99) , 
9, 0.359655, 1, 0, 0.560132,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.637002,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502901,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.162671,-99) , 
9, 0.18046, 0, 0, 0.331433,-99) , 
9, 0.119289, 1, 0, 0.411732,-99) , 
9, 0.264609, 0, 0, 0.503955,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.346355);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.667272,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407736,-99) , 
4, 2.5379, 1, 0, 0.592487,-99) , 
4, 9.83295, 0, 0, 0.640601,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.353031,-99) , 
0, 1.05557, 0, 0, 0.492117,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.406219);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.866754,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.706974,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.320598,-99) , 
9, 0.938515, 1, 0, 0.653312,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578435,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.302225,-99) , 
6, 0.00284575, 1, 0, 0.378126,-99) , 
7, 8.66934, 0, 0, 0.500257,-99) , 
7, 208.794, 0, 0, 0.521493,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.34814);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.632243, 0, 1, 0.654533,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.701996,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.320114,-99) , 
1, 3.70699, 0, 0, 0.381715,-99) , 
6, 0.0072561, 1, 0, 0.533503,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.400267);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.907403,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.671354,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.340356,-99) , 
4, 1.24877, 0, 0, 0.484733,-99) , 
NN(
0, 
0, 
-1, 0.479956, 1, -1, 0.2719,-99) , 
4, 7.73491, 1, 0, 0.446017,-99) , 
9, 0.938704, 0, 0, 0.473591,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.346142);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.769606,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.78331,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.394304,-99) , 
9, 0.478132, 1, 0, 0.508861,-99) , 
NN(
0, 
0, 
-1, 2.87581, 1, -1, 0.345809,-99) , 
9, 0.264601, 0, 0, 0.454761,-99) , 
0, 4.37507, 0, 0, 0.481926,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.327223);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.251697, 0, 1, 0.720342,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.707845,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497286,-99) , 
6, 0.0048281, 1, 0, 0.580813,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.215431,-99) , 
9, 0.474226, 0, 0, 0.529069,-99) , 
9, 0.417717, 1, 0, 0.609812,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.149297);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.111939, 1, 1, 0.559229,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.220332,-99) , 
8, 0.909508, 1, 0, 0.536368,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.461286);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.83675, 1, 1, 0.865397,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.655164,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.268686,-99) , 
0, 3.25525, 1, 0, 0.491451,-99) , 
9, 0.66282, 0, 0, 0.599494,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.308979,-99) , 
0, 1.06725, 0, 0, 0.458086,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.333798);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.54601, 1, 1, 0.845235,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.801764,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576766,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.361239,-99) , 
5, 1.36781, 0, 0, 0.441222,-99) , 
6, 0.000967495, 1, 0, 0.473364,-99) , 
5, 7.06678, 0, 0, 0.523368,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.327191);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00756849, 1, 1, 0.660422,-99) , 
NN(
0, 
0, 
-1, 10.618, 1, -1, 0.323904,-99) , 
6, 0.00145154, 0, 0, 0.595287,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.349248,-99) , 
1, 1.04472, 0, 0, 0.489574,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.215181);
  fForest.push_back( 
NN(
0, 
0, 
-1, 0.907987, 0, 1, 0.60596,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.315974);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.831767,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590181,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442396,-99) , 
9, 0.572812, 0, 0, 0.494097,-99) , 
5, 3.54102, 0, 0, 0.539278,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.799699,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.296696,-99) , 
5, 5.98732, 1, 0, 0.525309,-99) , 
NN(
0, 
0, 
-1, 3.38211, 1, -1, 0.26428,-99) , 
1, 3.89529, 0, 0, 0.363277,-99) , 
0, 2.13199, 1, 0, 0.476106,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.290942);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.3661, 0, 1, 0.642431,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630344,-99) , 
NN(
0, 
0, 
-1, 0.785351, 1, -1, 0.354686,-99) , 
6, 0.00773951, 0, 0, 0.453461,-99) , 
1, 1.62091, 1, 0, 0.571579,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.357272);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.308248, 1, 1, 0.787158,-99) , 
NN(
0, 
0, 
-1, 0.00193411, 0, -1, 0.396034,-99) , 
9, 0.230483, 0, 0, 0.531053,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.743203,-99) , 
NN(
0, 
0, 
-1, 7.61172, 1, -1, 0.332292,-99) , 
9, 0.946643, 0, 0, 0.36987,-99) , 
9, 0.448828, 1, 0, 0.439672,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.213392);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.00918955, 1, 1, 0.709772,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577116,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456473,-99) , 
9, 0.387944, 0, 0, 0.516935,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.293914,-99) , 
4, 10.1975, 1, 0, 0.486437,-99) , 
0, 2.16207, 0, 0, 0.529241,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.315368);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.819511,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481086,-99) , 
9, 0.816147, 1, 0, 0.740682,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494829,-99) , 
0, 1.0487, 0, 0, 0.616069,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.750178,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.21747,-99) , 
1, 4.28821, 0, 0, 0.381761,-99) , 
0, 3.89189, 1, 0, 0.573002,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.238989);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.902347,-99) , 
NN(
NN(
0, 
0, 
-1, 0.693582, 0, 1, 0.586237,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.371313,-99) , 
6, 0.00967429, 1, 0, 0.521223,-99) , 
5, 9.28583, 0, 0, 0.544086,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.441848);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.777093,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473839,-99) , 
6, 0.00286233, 0, 0, 0.689344,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.919744,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523923,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.208304,-99) , 
9, 0.325912, 0, 0, 0.340064,-99) , 
6, 0.00435438, 1, 0, 0.41874,-99) , 
0, 1.57554, 1, 0, 0.584064,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.435596);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.87019, 1, 1, 0.76405,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.380303,-99) , 
3, 1.8989, 0, 0, 0.503954,-99) , 
7, 16.5243, 0, 0, 0.598029,-99) , 
NN(
0, 
0, 
-1, 0.00241697, 0, -1, 0.341772,-99) , 
8, 0.101113, 1, 0, 0.534697,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.344433);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.00143236, 0, 1, 0.721651,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.745464,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434779,-99) , 
1, 1.46163, 1, 0, 0.64901,-99) , 
NN(
0, 
0, 
-1, 0.00487999, 0, -1, 0.389264,-99) , 
6, 0.00338063, 1, 0, 0.463272,-99) , 
9, 0.356521, 1, 0, 0.558291,-99)    );
   return;
};

// Clean up
inline void ReadBDTs::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDTs::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}

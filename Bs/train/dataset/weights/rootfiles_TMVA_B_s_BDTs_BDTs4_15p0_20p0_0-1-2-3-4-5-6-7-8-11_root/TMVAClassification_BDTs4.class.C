// Class: ReadBDTs4
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTs4
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.22/01       [398849]
Creator        : tasheng
Date           : Fri Feb 24 23:50:37 2023
Host           : Linux GRENDEL01.MIT.EDU 3.10.0-957.21.3.el7.x86_64 #1 SMP Tue Jun 18 16:35:19 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/tasheng/bmva_nom/bmva_trk5/TMVA/Bs/train
Training events: 16618
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "4" [Max depth of the decision tree allowed]
MinNodeSize: "5.0%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "30" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
BaggedSampleFraction: "5.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "5.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 10
Btrk1Pt                       Btrk1Pt                       Btrk1Pt                       Btrk1Pt                                                         'F'    [1.00026059151,7.99823522568]
Btrk2Pt                       Btrk2Pt                       Btrk2Pt                       Btrk2Pt                                                         'F'    [1.00003862381,8.20833110809]
abs(Btrk1Dz1/Btrk1DzError1)   Trk1DCAz                      Trk1DCAz                      Trk1DCAz                                                        'F'    [0.000585920701269,7067.48535156]
abs(Btrk2Dz1/Btrk2DzError1)   Trk2DCAz                      Trk2DCAz                      Trk2DCAz                                                        'F'    [0.00127403461374,7461.49121094]
abs(Btrk1Dxy1/Btrk1DxyError1) Trk1DCAxy                     Trk1DCAxy                     Trk1DCAxy                                                       'F'    [0.000318049656926,90.0913162231]
abs(Btrk2Dxy1/Btrk2DxyError1) Trk2DCAxy                     Trk2DCAxy                     Trk2DCAxy                                                       'F'    [0.000450126710348,118.972671509]
abs(Btktkmass-1.019455)       MassDis                       MassDis                       MassDis                                                         'F'    [7.52639763846e-08,0.0149851599708]
BsvpvDistance/BsvpvDisErr     dls                           dls                           dls                                                             'F'    [2.00074076653,8667.96289062]
Balpha                        Balpha                        Balpha                        Balpha                                                          'F'    [4.53386019217e-05,3.13193774223]
Bchi2cl                       Bchi2cl                       Bchi2cl                       Bchi2cl                                                         'F'    [0.0501388795674,0.999954462051]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDTs4Node

#ifndef BDTs4Node__def
#define BDTs4Node__def

class BDTs4Node {

public:

   // constructor of an essentially "empty" node floating in space
   BDTs4Node ( BDTs4Node* left,BDTs4Node* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTs4Node();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTs4Node* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTs4Node* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTs4Node*   fLeft;     // pointer to the left daughter node
   BDTs4Node*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDTs4Node::~BDTs4Node()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDTs4Node::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] >= fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDTs4Node::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTs4 : public IClassifierReader {

 public:

   // constructor
   ReadBDTs4( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDTs4" ),
        fNvars( 10 )
   {
      // the training input variables
      const char* inputVars[] = { "Btrk1Pt", "Btrk2Pt", "abs(Btrk1Dz1/Btrk1DzError1)", "abs(Btrk2Dz1/Btrk2DzError1)", "abs(Btrk1Dxy1/Btrk1DxyError1)", "abs(Btrk2Dxy1/Btrk2DxyError1)", "abs(Btktkmass-1.019455)", "BsvpvDistance/BsvpvDisErr", "Balpha", "Bchi2cl" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTs4() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[10];
   double fVmax[10];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[10];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTs4Node*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTs4::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTs4Node *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTs4Node*)current->GetRight();
         else current=(BDTs4Node*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDTs4::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(0.933911792627457);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.65323, 0, 1, 0.927185,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.761789,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.197046,-99) , 
4, 2.32563, 0, 0, 0.380602,-99) , 
9, 0.203314, 0, 0, 0.752369,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575007,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0950371,-99) , 
6, 0.0029019, 1, 0, 0.195935,-99) , 
1, 1.46509, 0, 0, 0.553919,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.842782);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452747,-99) , 
0, 1.44532, 0, 0, 0.866459,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492854,-99) , 
9, 0.325977, 0, 0, 0.750489,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.654683,-99) , 
NN(
0, 
0, 
-1, 1.88472, 0, -1, 0.126609,-99) , 
0, 2.957, 0, 0, 0.203855,-99) , 
4, 1.12611, 0, 0, 0.322176,-99) , 
4, 2.90763, 0, 0, 0.489682,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.826238);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.44252, 0, 1, 0.918634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40136,-99) , 
9, 0.938571, 1, 0, 0.82954,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.658519,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514154,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.122197,-99) , 
9, 0.571345, 0, 0, 0.185221,-99) , 
5, 1.83431, 0, 0, 0.264562,-99) , 
4, 4.49512, 0, 0, 0.370755,-99) , 
6, 0.00337584, 1, 0, 0.558794,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.827366);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.201342, 1, 1, 0.908183,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.886075,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.854892,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.300855,-99) , 
6, 0.00564509, 1, 0, 0.514056,-99) , 
NN(
0, 
0, 
-1, 0.570416, 0, -1, 0.17168,-99) , 
5, 1.11589, 0, 0, 0.286988,-99) , 
5, 5.76014, 0, 0, 0.359937,-99) , 
6, 0.0024166, 1, 0, 0.504809,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.541437);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 1.66615, 0, 1, 0.81289,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448682,-99) , 
1, 4.66423, 1, 0, 0.758353,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.344019,-99) , 
1, 1.43195, 0, 0, 0.643193,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.233784,-99) , 
6, 0.00870149, 1, 0, 0.545126,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.741129);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.00773547, 1, 1, 0.940696,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.848184,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.705917,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.29081,-99) , 
4, 1.5943, 0, 0, 0.352459,-99) , 
0, 3.48341, 0, 0, 0.429057,-99) , 
6, 0.00143274, 1, 0, 0.492224,-99) , 
4, 2.90648, 0, 0, 0.628342,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.589113);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 2.29122, 0, 1, 0.804801,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.842776,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.328705,-99) , 
8, 0.0451828, 1, 0, 0.555708,-99) , 
6, 0.000966591, 0, 0, 0.749935,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.313207,-99) , 
8, 1.41445, 1, 0, 0.70085,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.674416,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.251175,-99) , 
5, 3.51171, 0, 0, 0.349217,-99) , 
1, 1.43193, 0, 0, 0.588018,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.566474);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.54808, 1, 1, 0.868623,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471867,-99) , 
9, 0.754768, 0, 0, 0.553307,-99) , 
5, 1.97346, 0, 0, 0.636408,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.236641,-99) , 
0, 1.67857, 0, 0, 0.451344,-99) , 
4, 2.66599, 0, 0, 0.561788,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.572029);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.203483, 0, 1, 0.856406,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373216,-99) , 
8, 0.707281, 1, 0, 0.769269,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0.326389, 0, 1, 0.766124,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.337522,-99) , 
0, 1.89596, 0, 0, 0.507727,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.242888,-99) , 
1, 3.99713, 1, 0, 0.438811,-99) , 
6, 0.0038563, 1, 0, 0.577416,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.499514);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 3.86541, 1, 1, 0.89609,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.808876,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.339601,-99) , 
0, 2.58512, 1, 0, 0.672853,-99) , 
1, 2.2976, 0, 0, 0.792569,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454062,-99) , 
6, 0.00966917, 1, 0, 0.722271,-99) , 
NN(
0, 
0, 
-1, 1.20598, 0, -1, 0.36134,-99) , 
0, 1.45364, 0, 0, 0.604519,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.468946);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.1117, 1, 1, 0.884263,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0.00977147, 1, 1, 0.590198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.286965,-99) , 
8, 0.300632, 1, 0, 0.529399,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.236118,-99) , 
1, 1.40628, 0, 0, 0.411149,-99) , 
9, 0.632376, 0, 0, 0.510023,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.45099);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00627663, 1, 1, 0.827539,-99) , 
NN(
NN(
0, 
0, 
-1, 2.66635, 0, 1, 0.661787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.192416,-99) , 
0, 2.57305, 1, 0, 0.556938,-99) , 
0, 2.80622, 0, 0, 0.621776,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.343677,-99) , 
9, 0.142057, 0, 0, 0.56249,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.56461);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.100498, 1, 1, 0.825511,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.854574,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.334696,-99) , 
8, 0.00769926, 1, 0, 0.405264,-99) , 
8, 0.0782429, 0, 0, 0.453359,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.17022,-99) , 
8, 0.606297, 1, 0, 0.393288,-99) , 
6, 0.00193022, 1, 0, 0.467869,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.505754);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.142281, 0, 1, 0.837151,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.826715,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510141,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.296835,-99) , 
1, 1.39283, 1, 0, 0.411691,-99) , 
6, 0.00294746, 0, 0, 0.604081,-99) , 
1, 1.64224, 0, 0, 0.734867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.381497,-99) , 
6, 0.0101515, 1, 0, 0.634254,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.589026);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.44085, 0, 1, 0.947933,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.832685,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561007,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.336523,-99) , 
9, 0.448326, 0, 0, 0.413514,-99) , 
5, 1.51683, 0, 0, 0.474077,-99) , 
4, 1.3759, 0, 0, 0.549636,-99) , 
4, 2.66655, 0, 0, 0.644836,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.419753);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.79138, 1, 1, 0.846543,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 3.26726, 0, 1, 0.842273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.352247,-99) , 
4, 0.462472, 0, 0, 0.608828,-99) , 
NN(
0, 
0, 
-1, 1.78558, 1, -1, 0.397665,-99) , 
0, 2.35471, 0, 0, 0.46829,-99) , 
4, 2.38709, 0, 0, 0.559036,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.605348);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 2.07979, 1, 1, 0.873538,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.343288,-99) , 
9, 0.938684, 1, 0, 0.772978,-99) , 
NN(
NN(
0, 
0, 
-1, 1.18932, 0, 1, 0.78718,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.341606,-99) , 
7, 5.14033, 0, 0, 0.47893,-99) , 
7, 10.1101, 0, 0, 0.600386,-99) , 
7, 255.312, 0, 0, 0.627712,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.604909);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 5.2257, 1, 1, 0.975817,-99) , 
NN(
NN(
0, 
0, 
-1, 0.2047, 0, 1, 0.722938,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.729392,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.337271,-99) , 
9, 0.545149, 1, 0, 0.575813,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.256172,-99) , 
0, 3.81015, 1, 0, 0.508165,-99) , 
9, 0.331961, 1, 0, 0.629785,-99) , 
9, 0.632339, 0, 0, 0.699791,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.558903);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.00531896, 1, 1, 0.769832,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.332342,-99) , 
8, 1.4026, 1, 0, 0.700251,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.53146);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 5.33333, 1, 1, 0.830809,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483105,-99) , 
8, 1.31342, 1, 0, 0.752092,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.208028,-99) , 
0, 4.94594, 1, 0, 0.636232,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.776504,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.293062,-99) , 
4, 3.95829, 0, 0, 0.351934,-99) , 
1, 1.64788, 0, 0, 0.506524,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.503902);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.68978, 0, 1, 0.960949,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.879179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.408148,-99) , 
9, 0.520169, 1, 0, 0.772317,-99) , 
9, 0.598766, 0, 0, 0.841109,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.367128,-99) , 
9, 0.111642, 0, 0, 0.744444,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.685574,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.376717,-99) , 
9, 0.54034, 1, 0, 0.552974,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.367199,-99) , 
0, 1.67217, 1, 0, 0.495494,-99) , 
1, 1.6479, 0, 0, 0.616053,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.471029);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.886735,-99) , 
NN(
NN(
0, 
0, 
-1, 0.00578709, 1, 1, 0.809939,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.713597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.342836,-99) , 
9, 0.908021, 1, 0, 0.630422,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569974,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.266013,-99) , 
0, 2.23948, 1, 0, 0.459066,-99) , 
6, 0.00531728, 1, 0, 0.553561,-99) , 
0, 3.19246, 0, 0, 0.599362,-99) , 
0, 1.226, 1, 0, 0.637135,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.619567);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.57137, 1, 1, 0.861042,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.35474, 1, -1, 0.316502,-99) , 
9, 0.693761, 0, 0, 0.394798,-99) , 
1, 1.6479, 0, 0, 0.578472,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.630735);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0992865, 1, 1, 0.850937,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647068,-99) , 
NN(
0, 
0, 
-1, 0.130401, 1, -1, 0.224565,-99) , 
1, 2.21771, 1, 0, 0.404563,-99) , 
9, 0.216158, 0, 0, 0.609842,-99) , 
NN(
0, 
0, 
-1, 2.67931, 1, -1, 0.226003,-99) , 
9, 0.908037, 1, 0, 0.532182,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.44554);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.82162, 0, 1, 0.965082,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.875064,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.623022,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416601,-99) , 
4, 0.94058, 1, 0, 0.534628,-99) , 
4, 2.91035, 0, 0, 0.578164,-99) , 
9, 0.632075, 0, 0, 0.65004,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.258792,-99) , 
0, 1.21072, 0, 0, 0.569244,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.48467);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 1.14246, 0, 1, 0.805814,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.283566,-99) , 
5, 2.95084, 1, 0, 0.725169,-99) , 
5, 3.66225, 0, 0, 0.772389,-99) , 
NN(
0, 
0, 
-1, 0, 1, 1, 0.500718,-99) , 
6, 0.00869957, 1, 0, 0.687024,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.381204);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.632379, 1, 1, 0.841963,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.911098,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602124,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.364636,-99) , 
6, 0.00490655, 1, 0, 0.540752,-99) , 
6, 0.0065762, 0, 0, 0.584462,-99) , 
6, 0.00140271, 1, 0, 0.630637,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.316668,-99) , 
6, 0.00870144, 1, 0, 0.539075,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.574481);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.662765, 1, 1, 0.948177,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 2.06733, 0, 1, 0.938951,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.351047,-99) , 
4, 3.77183, 1, 0, 0.685255,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.667479,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539007,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.238643,-99) , 
9, 0.570951, 0, 0, 0.290088,-99) , 
4, 1.11236, 0, 0, 0.33372,-99) , 
4, 1.56889, 0, 0, 0.402599,-99) , 
5, 3.83919, 0, 0, 0.462963,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.610721);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.937438,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 1.17307, 0, 1, 0.828304,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.335492,-99) , 
4, 3.85766, 1, 0, 0.710236,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.820275,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581323,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.173902,-99) , 
5, 0.862321, 1, 0, 0.342049,-99) , 
5, 1.57208, 0, 0, 0.408944,-99) , 
4, 1.2314, 0, 0, 0.493586,-99) , 
4, 4.77219, 0, 0, 0.540874,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.466702);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.64899, 0, 1, 0.915587,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463818,-99) , 
9, 0.391035, 1, 0, 0.690728,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.76292,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378578,-99) , 
5, 0.941611, 0, 0, 0.580484,-99) , 
NN(
0, 
0, 
-1, 0.277908, 0, -1, 0.307643,-99) , 
6, 0.00193402, 1, 0, 0.348031,-99) , 
5, 3.66235, 0, 0, 0.389475,-99) , 
9, 0.754809, 0, 0, 0.438036,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.625309);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 1.52922, 0, 1, 0.853707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490152,-99) , 
0, 4.28756, 1, 0, 0.810633,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.188636,-99) , 
9, 0.295816, 0, 0, 0.322006,-99) , 
6, 0.00117084, 1, 0, 0.512569,-99) , 
6, 0.00241887, 0, 0, 0.714566,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.349019,-99) , 
8, 1.58632, 1, 0, 0.647766,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.504686);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.44494, 1, 1, 0.972499,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413196,-99) , 
0, 3.2602, 0, 0, 0.502306,-99) , 
8, 0.0992892, 0, 0, 0.603329,-99) , 
1, 1.42816, 1, 0, 0.698004,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.376595,-99) , 
6, 0.00869997, 1, 0, 0.594018,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.503715);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.88774,-99) , 
NN(
NN(
0, 
0, 
-1, 0.203471, 0, 1, 0.846224,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.882421,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426708,-99) , 
9, 0.54033, 1, 0, 0.626894,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.325949,-99) , 
7, 5.3416, 0, 0, 0.472172,-99) , 
7, 27.879, 0, 0, 0.534985,-99) , 
7, 272.632, 0, 0, 0.566804,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.47125);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.42472, 0, 1, 0.962681,-99) , 
NN(
NN(
0, 
0, 
-1, 0.2568, 0, 1, 0.848145,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.797844,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486579,-99) , 
0, 1.75946, 0, 0, 0.604767,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516583,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.175371,-99) , 
0, 2.99364, 0, 0, 0.278737,-99) , 
0, 2.5684, 1, 0, 0.527466,-99) , 
1, 3.55042, 0, 0, 0.565556,-99) , 
9, 0.632336, 0, 0, 0.631382,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.557148);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.00664, 1, 1, 0.928254,-99) , 
NN(
NN(
0, 
0, 
-1, 0.00337904, 1, 1, 0.759172,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.818557,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.353782,-99) , 
9, 0.571281, 0, 0, 0.432051,-99) , 
1, 2.27681, 0, 0, 0.533234,-99) , 
4, 2.06251, 0, 0, 0.593354,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.665513,-99) , 
NN(
0, 
0, 
-1, 3.8875, 1, -1, 0.132413,-99) , 
0, 2.53151, 1, 0, 0.282977,-99) , 
4, 5.81264, 1, 0, 0.522061,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.501378);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.0349459, 1, 1, 0.813006,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434778,-99) , 
1, 4.40871, 1, 0, 0.769767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.358204,-99) , 
8, 1.10016, 1, 0, 0.697,-99) , 
NN(
NN(
0, 
0, 
-1, 0.154028, 1, 1, 0.758852,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.348264,-99) , 
6, 0.00381197, 1, 0, 0.491366,-99) , 
9, 0.264798, 0, 0, 0.615688,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.535311);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 236.334, 0, 1, 0.823659,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.809208,-99) , 
NN(
0, 
0, 
-1, 0.00287661, 0, -1, 0.381617,-99) , 
1, 1.2507, 1, 0, 0.525137,-99) , 
1, 1.64788, 0, 0, 0.656788,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.428426);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 1.8242, 0, 1, 0.939935,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.885597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.411574,-99) , 
0, 1.75241, 1, 0, 0.662082,-99) , 
0, 1.94246, 0, 0, 0.819686,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.669265,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.317222,-99) , 
9, 0.417224, 0, 0, 0.424247,-99) , 
1, 3.7145, 1, 0, 0.691435,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528196,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.348366,-99) , 
9, 0.510105, 1, 0, 0.453107,-99) , 
0, 1.45174, 0, 0, 0.586407,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.439873);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.931842, 1, 1, 0.876344,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476333,-99) , 
0, 4.16087, 1, 0, 0.810121,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462897,-99) , 
8, 1.31345, 1, 0, 0.720518,-99) , 
NN(
NN(
0, 
0, 
-1, 3.73115, 1, 1, 0.751459,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560121,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.343834,-99) , 
6, 0.0019065, 1, 0, 0.377736,-99) , 
1, 2.65672, 0, 0, 0.463076,-99) , 
9, 0.295396, 0, 0, 0.59464,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.586044);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.84166, 1, 1, 0.902637,-99) , 
NN(
NN(
0, 
0, 
-1, 3.7532, 1, 1, 0.818919,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602589,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500207,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.251679,-99) , 
9, 0.636426, 1, 0, 0.350078,-99) , 
1, 1.45, 1, 0, 0.477777,-99) , 
1, 1.93045, 0, 0, 0.596571,-99) , 
9, 0.295507, 1, 0, 0.699317,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.268985);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.794753,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.898595,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470886,-99) , 
4, 2.06297, 0, 0, 0.54928,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.265936,-99) , 
4, 15.9916, 1, 0, 0.527337,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.239068,-99) , 
1, 4.25881, 1, 0, 0.501626,-99) , 
1, 4.88722, 0, 0, 0.518829,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.52466);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.861996,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587994,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.352585,-99) , 
0, 4.15732, 0, 0, 0.470713,-99) , 
0, 3.33437, 1, 0, 0.636717,-99) , 
6, 0.00337657, 1, 0, 0.747869,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 1.8296, 0, 1, 0.79835,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.808702,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.395267,-99) , 
9, 0.601933, 0, 0, 0.488542,-99) , 
0, 1.49807, 0, 0, 0.591938,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.209352,-99) , 
0, 2.10307, 1, 0, 0.534297,-99) , 
0, 2.31521, 0, 0, 0.596322,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.466718);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 2.87427, 0, 1, 0.792093,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444059,-99) , 
9, 0.907966, 1, 0, 0.74413,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421196,-99) , 
1, 1.23383, 0, 0, 0.660778,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.250915,-99) , 
1, 4.62437, 1, 0, 0.605562,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.475018);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.510218, 0, 1, 0.925672,-99) , 
NN(
NN(
0, 
0, 
-1, 1.88454, 0, 1, 0.758196,-99) , 
NN(
NN(
0, 
0, 
-1, 0.701338, 0, 1, 0.707973,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.362158,-99) , 
9, 0.387135, 0, 0, 0.479573,-99) , 
5, 1.3626, 0, 0, 0.563957,-99) , 
5, 3.83909, 0, 0, 0.610531,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.533349);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.571443, 1, 1, 0.906593,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.649628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.324326,-99) , 
0, 4.79711, 1, 0, 0.558109,-99) , 
1, 2.16267, 1, 0, 0.744142,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.374965,-99) , 
8, 0.0551321, 1, 0, 0.649012,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.877043,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.313101,-99) , 
7, 272.648, 0, 0, 0.459399,-99) , 
8, 0.100637, 1, 0, 0.587841,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.500471);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.78552, 1, 1, 0.884256,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 1.95639, 1, 1, 0.830163,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.597911,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.301485,-99) , 
9, 0.341321, 1, 0, 0.46566,-99) , 
4, 1.28965, 0, 0, 0.520914,-99) , 
9, 0.693731, 0, 0, 0.56432,-99) , 
4, 2.6654, 0, 0, 0.617138,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.347203);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 1.6479, 0, 1, 0.862707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497416,-99) , 
6, 0.000936897, 0, 0, 0.764354,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438778,-99) , 
4, 2.31851, 0, 0, 0.515923,-99) , 
6, 0.00483418, 1, 0, 0.622046,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.683967,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.360622,-99) , 
5, 2.25112, 0, 0, 0.399064,-99) , 
9, 0.203499, 0, 0, 0.528165,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.488292);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.119813, 0, 1, 0.784723,-99) , 
NN(
NN(
0, 
0, 
-1, 0.31786, 0, 1, 0.772881,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425911,-99) , 
1, 2.71253, 1, 0, 0.652908,-99) , 
9, 0.216152, 1, 0, 0.721528,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.760208,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.827274,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396962,-99) , 
0, 2.04054, 1, 0, 0.652252,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.326485,-99) , 
6, 0.00386817, 1, 0, 0.439872,-99) , 
0, 2.79458, 0, 0, 0.489223,-99) , 
9, 0.478932, 1, 0, 0.609585,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.564788);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00401087, 1, 1, 0.803167,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.32645,-99) , 
6, 0.000296263, 0, 0, 0.739684,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.293865,-99) , 
6, 0.00915899, 1, 0, 0.571208,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.464728);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.264613, 0, 1, 0.806422,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.286478,-99) , 
4, 11.2359, 1, 0, 0.754148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422112,-99) , 
8, 1.50894, 1, 0, 0.696188,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420545,-99) , 
1, 1.23298, 0, 0, 0.631867,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.459521);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.336018, 1, 1, 0.843897,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418,-99) , 
8, 0.303172, 1, 0, 0.737639,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455233,-99) , 
9, 0.142226, 0, 0, 0.658147,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.25776,-99) , 
4, 15.9908, 1, 0, 0.629665,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.477217);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.598138, 0, 1, 0.911079,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534407,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432963,-99) , 
6, 0.00241789, 0, 0, 0.485698,-99) , 
9, 0.911115, 1, 0, 0.763444,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.685785,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.601584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.188782,-99) , 
1, 2.88361, 0, 0, 0.416506,-99) , 
1, 2.22767, 1, 0, 0.572335,-99) , 
NN(
0, 
0, 
-1, 0.00240873, 0, -1, 0.293543,-99) , 
9, 0.332748, 1, 0, 0.489861,-99) , 
9, 0.448447, 0, 0, 0.571657,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.396763);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.893675,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.78596,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.697241,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.304484,-99) , 
6, 0.00457557, 1, 0, 0.503306,-99) , 
6, 0.00676825, 0, 0, 0.577291,-99) , 
NN(
0, 
0, 
-1, 1.26058, 1, -1, 0.409749,-99) , 
0, 1.44865, 0, 0, 0.504687,-99) , 
3, 240.696, 0, 0, 0.546814,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.474759);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 1.34536, 1, 1, 0.973712,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.835798,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439695,-99) , 
6, 0.00144851, 0, 0, 0.734843,-99) , 
8, 0.0992385, 0, 0, 0.836431,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.695938,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433363,-99) , 
1, 1.4097, 1, 0, 0.582738,-99) , 
0, 1.44862, 0, 0, 0.726886,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424247,-99) , 
9, 0.111731, 0, 0, 0.660632,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.536519);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.920851,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440742,-99) , 
0, 2.69782, 1, 0, 0.772961,-99) , 
NN(
NN(
0, 
0, 
-1, 0.958522, 1, 1, 0.862107,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.914415,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413949,-99) , 
6, 0.00674847, 1, 0, 0.589487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.365131,-99) , 
8, 0.101122, 1, 0, 0.490968,-99) , 
9, 0.678744, 0, 0, 0.567123,-99) , 
9, 0.233974, 1, 0, 0.638455,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.468378);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 1.41715, 0, 1, 0.711104,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.411824,-99) , 
9, 0.537293, 1, 0, 0.67206,-99) , 
9, 0.631192, 0, 0, 0.69892,-99) , 
NN(
0, 
0, 
-1, 2.6812, 1, -1, 0.289571,-99) , 
9, 0.908056, 1, 0, 0.630859,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.269151);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.921648,-99) , 
NN(
NN(
0, 
0, 
-1, 2.96853, 0, 1, 0.588015,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.283638,-99) , 
1, 4.61308, 1, 0, 0.5531,-99) , 
3, 232.176, 0, 0, 0.586244,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.460032);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.99219, 0, 1, 0.719499,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.800426,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471426,-99) , 
9, 0.326031, 1, 0, 0.613516,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579873,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.237965,-99) , 
6, 0.00385154, 1, 0, 0.306499,-99) , 
3, 2.01866, 0, 0, 0.396038,-99) , 
8, 0.00656245, 1, 0, 0.431825,-99) , 
8, 0.100452, 0, 0, 0.506974,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.456596);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.100697, 0, 1, 0.847832,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.805563,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443597,-99) , 
8, 0.202103, 1, 0, 0.666487,-99) , 
9, 0.479195, 1, 0, 0.774488,-99) , 
NN(
NN(
0, 
0, 
-1, 0.688513, 0, 1, 0.631134,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.343501,-99) , 
9, 0.356895, 0, 0, 0.488051,-99) , 
0, 1.65184, 0, 0, 0.623094,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.494619);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.937227,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.690882,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489579,-99) , 
1, 3.12252, 0, 0, 0.603667,-99) , 
0, 2.23122, 1, 0, 0.7799,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 3.84686, 1, 1, 0.716255,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.612465,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.227467,-99) , 
1, 1.81482, 1, 0, 0.49202,-99) , 
0, 1.90427, 0, 0, 0.586316,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.215456,-99) , 
9, 0.283582, 0, 0, 0.510598,-99) , 
9, 0.234125, 1, 0, 0.591015,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.40558);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0011843, 1, 1, 0.870939,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.708996,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.673997,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.376964,-99) , 
0, 1.90359, 0, 0, 0.44807,-99) , 
6, 0.00739843, 0, 0, 0.526459,-99) , 
6, 0.00193205, 1, 0, 0.568875,-99) , 
NN(
0, 
0, 
-1, 0.95262, 0, -1, 0.271339,-99) , 
9, 0.908066, 1, 0, 0.511528,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.355477);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.172827, 0, 1, 0.969947,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399688,-99) , 
5, 5.56237, 1, 0, 0.794485,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529507,-99) , 
NN(
0, 
0, 
-1, 0.354976, 0, -1, 0.372994,-99) , 
6, 0.00483369, 0, 0, 0.440151,-99) , 
4, 1.37533, 0, 0, 0.531975,-99) , 
NN(
0, 
0, 
-1, 2.53335, 1, -1, 0.226531,-99) , 
4, 10.6607, 1, 0, 0.492644,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.33292);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.940438,-99) , 
NN(
NN(
0, 
0, 
-1, 2.58431, 0, 1, 0.638312,-99) , 
NN(
0, 
0, 
-1, 0.0262793, 1, -1, 0.39571,-99) , 
1, 3.72864, 1, 0, 0.590532,-99) , 
8, 0.135827, 0, 0, 0.62732,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.354483,-99) , 
8, 1.41448, 1, 0, 0.575745,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.42798);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 1.34596, 0, 1, 0.854302,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.384249,-99) , 
1, 3.68152, 1, 0, 0.746363,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.742926,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.375364,-99) , 
1, 2.59839, 0, 0, 0.458025,-99) , 
9, 0.203319, 0, 0, 0.611606,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.362088,-99) , 
6, 0.00916286, 1, 0, 0.534825,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.441173);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.957338,-99) , 
NN(
NN(
0, 
0, 
-1, 3.77088, 1, 1, 0.800952,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.923524,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.305837,-99) , 
9, 0.295439, 0, 0, 0.413076,-99) , 
0, 2.80625, 0, 0, 0.463208,-99) , 
7, 19.2548, 0, 0, 0.527411,-99) , 
7, 272.633, 0, 0, 0.564891,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.479499);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00435151, 1, 1, 0.822131,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.843617,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.712936,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.3111,-99) , 
8, 0.101117, 0, 0, 0.414901,-99) , 
1, 4.18869, 0, 0, 0.498902,-99) , 
0, 2.5707, 1, 0, 0.638178,-99) , 
NN(
0, 
0, 
-1, 1.23047, 0, -1, 0.353018,-99) , 
1, 1.42027, 0, 0, 0.534351,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.44896);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.91906, 1, 1, 0.856283,-99) , 
NN(
NN(
0, 
0, 
-1, 1.43234, 0, 1, 0.80105,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.129846,-99) , 
6, 0.00211131, 1, 0, 0.484843,-99) , 
6, 0.00242507, 0, 0, 0.665431,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532405,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.314622,-99) , 
6, 0.00795957, 0, 0, 0.48263,-99) , 
6, 0.00627712, 1, 0, 0.577013,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.340602);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.775721,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.601628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424897,-99) , 
6, 0.0043376, 1, 0, 0.485531,-99) , 
9, 0.143294, 1, 0, 0.539836,-99) , 
1, 2.89021, 0, 0, 0.578487,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518791,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.157535,-99) , 
9, 0.265902, 0, 0, 0.306007,-99) , 
1, 3.79035, 1, 0, 0.521366,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.407699);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.203493, 0, 1, 0.741199,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.666928,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.666101,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.66926,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.305905,-99) , 
3, 9.96064, 0, 0, 0.342153,-99) , 
3, 156.946, 0, 0, 0.373658,-99) , 
9, 0.142233, 1, 0, 0.419115,-99) , 
0, 3.1918, 0, 0, 0.463011,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.531766);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.883092,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.661886,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.371243,-99) , 
5, 1.13265, 1, 0, 0.499526,-99) , 
7, 18.6484, 0, 0, 0.555576,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.853399,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.269031,-99) , 
9, 0.14498, 0, 0, 0.485653,-99) , 
NN(
0, 
0, 
-1, 3.14637, 0, -1, 0.190645,-99) , 
9, 0.540299, 1, 0, 0.35314,-99) , 
1, 2.39519, 1, 0, 0.468667,-99) , 
7, 261.516, 0, 0, 0.500843,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.48451);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.69793, 0, 1, 0.878093,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.68531,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581368,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407948,-99) , 
9, 0.193111, 0, 0, 0.482959,-99) , 
9, 0.105647, 1, 0, 0.537566,-99) , 
9, 0.264749, 0, 0, 0.709042,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.347077,-99) , 
8, 1.81071, 1, 0, 0.62437,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.54806);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.66403, 1, 1, 0.795451,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 2.86739, 0, 1, 0.838319,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.28799,-99) , 
0, 3.59038, 1, 0, 0.531233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.291986,-99) , 
0, 1.87639, 0, 0, 0.385544,-99) , 
6, 0.00434093, 1, 0, 0.501549,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.445453);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0.00241371, 0, 1, 0.799073,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.739677,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40284,-99) , 
5, 2.33187, 0, 0, 0.480735,-99) , 
0, 2.17974, 0, 0, 0.556172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.215994,-99) , 
0, 5.0636, 1, 0, 0.513268,-99) , 
2, 227.984, 0, 0, 0.551163,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.57459);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.926219,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.722652,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.349928,-99) , 
0, 3.69069, 1, 0, 0.649112,-99) , 
8, 0.0521848, 0, 0, 0.752431,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.383272,-99) , 
8, 0.404201, 1, 0, 0.668121,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.775054,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.410929,-99) , 
0, 2.72845, 1, 0, 0.639094,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.119847,-99) , 
6, 0.00210317, 1, 0, 0.399618,-99) , 
6, 0.0024177, 0, 0, 0.599042,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.455715);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.945816,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.692057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42297,-99) , 
1, 1.22706, 1, 0, 0.579404,-99) , 
1, 1.41435, 0, 0, 0.676955,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.827049,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.697575,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.377271,-99) , 
0, 4.4762, 0, 0, 0.473061,-99) , 
0, 2.65919, 1, 0, 0.55672,-99) , 
NN(
0, 
0, 
-1, 1.82938, 1, -1, 0.255892,-99) , 
1, 2.02897, 0, 0, 0.473402,-99) , 
1, 1.64222, 1, 0, 0.568703,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.422944);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.883532,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.795581,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.773852,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441368,-99) , 
8, 0.101355, 0, 0, 0.561362,-99) , 
0, 3.73454, 0, 0, 0.654544,-99) , 
1, 2.59583, 1, 0, 0.721036,-99) , 
NN(
NN(
0, 
0, 
-1, 0.00522758, 1, 1, 0.610495,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.684397,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.19987,-99) , 
6, 0.00158723, 1, 0, 0.332442,-99) , 
6, 0.00289471, 0, 0, 0.510155,-99) , 
1, 1.85282, 0, 0, 0.589526,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.496809);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 7.68825, 1, 1, 0.942925,-99) , 
NN(
NN(
0, 
0, 
-1, 2.73066, 0, 1, 0.748597,-99) , 
NN(
NN(
0, 
0, 
-1, 1.89808, 1, 1, 0.766984,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404668,-99) , 
4, 1.16828, 0, 0, 0.538577,-99) , 
4, 0.750451, 1, 0, 0.629587,-99) , 
4, 2.90707, 0, 0, 0.670608,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.423029);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 2.23739, 1, 1, 0.910057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473013,-99) , 
1, 3.8087, 1, 0, 0.785496,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.761452,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.348926,-99) , 
0, 1.27471, 1, 0, 0.522239,-99) , 
0, 1.44869, 0, 0, 0.6817,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399388,-99) , 
6, 0.0091735, 1, 0, 0.574858,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.48269);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0.509726, 0, 1, 0.731831,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.720384,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5673,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.318886,-99) , 
1, 1.82336, 1, 0, 0.478535,-99) , 
1, 3.12619, 0, 0, 0.518442,-99) , 
6, 0.00434538, 0, 0, 0.63256,-99) , 
3, 240.695, 0, 0, 0.680476,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.435559);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0.417915, 1, 1, 0.938808,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451451,-99) , 
0, 1.44252, 0, 0, 0.707334,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.758203,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.376968,-99) , 
9, 0.456423, 1, 0, 0.489055,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.330045,-99) , 
9, 0.234179, 0, 0, 0.422149,-99) , 
6, 0.00386749, 1, 0, 0.486767,-99) , 
2, 227.984, 0, 0, 0.518314,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.494323);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.958459, 1, 1, 0.875794,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.840148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487865,-99) , 
6, 0.00435124, 0, 0, 0.712475,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.369121,-99) , 
5, 0.945333, 0, 0, 0.529239,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.109134,-99) , 
5, 14.6456, 1, 0, 0.493777,-99) , 
9, 0.571094, 0, 0, 0.571271,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.381707);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 4.14154, 1, 1, 0.736989,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.633473,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481535,-99) , 
6, 0.00289529, 0, 0, 0.587586,-99) , 
1, 1.63955, 0, 0, 0.678113,-99) , 
2, 208.421, 0, 0, 0.704772,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.383428,-99) , 
0, 1.22448, 0, 0, 0.611715,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.345998);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.2531, 1, 1, 0.696798,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429426,-99) , 
9, 0.14205, 0, 0, 0.632431,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.321955);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 2.09673, 1, 1, 0.925053,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.615944,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462468,-99) , 
6, 0.00503284, 0, 0, 0.556379,-99) , 
4, 2.36302, 0, 0, 0.599621,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581783,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.287634,-99) , 
6, 0.000594168, 1, 0, 0.436585,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.175135,-99) , 
1, 3.15136, 1, 0, 0.352307,-99) , 
6, 0.000968346, 0, 0, 0.562028,-99) , 
7, 281.548, 0, 0, 0.584209,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.411365);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0.00229242, 0, 1, 0.809668,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.814224,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465583,-99) , 
6, 0.00389304, 1, 0, 0.551408,-99) , 
9, 0.448354, 0, 0, 0.619368,-99) , 
5, 3.83826, 0, 0, 0.673735,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.319232,-99) , 
6, 0.0101495, 1, 0, 0.512699,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.35067);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.387067, 0, 1, 0.660895,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.934362,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.297246,-99) , 
5, 11.001, 1, 0, 0.622838,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.787183,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428124,-99) , 
0, 1.85729, 0, 0, 0.491644,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.295054,-99) , 
5, 0.597314, 0, 0, 0.413195,-99) , 
4, 2.66599, 0, 0, 0.440003,-99) , 
0, 3.21167, 0, 0, 0.477195,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.409085);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.116233, 0, 1, 0.85109,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.82634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464816,-99) , 
9, 0.565578, 0, 0, 0.670732,-99) , 
9, 0.38776, 1, 0, 0.788015,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.702753,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.41808,-99) , 
6, 0.00658626, 0, 0, 0.543423,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.410729,-99) , 
6, 0.0093978, 1, 0, 0.468975,-99) , 
6, 0.00482235, 1, 0, 0.611372,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.491896);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.00626481, 1, 1, 0.882091,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.802867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422381,-99) , 
4, 2.9586, 1, 0, 0.628574,-99) , 
0, 2.58051, 1, 0, 0.779993,-99) , 
NN(
NN(
0, 
0, 
-1, 0.265836, 0, 1, 0.740993,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426436,-99) , 
4, 0.632034, 1, 0, 0.59447,-99) , 
4, 1.03232, 0, 0, 0.672414,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.234891,-99) , 
4, 15.9918, 1, 0, 0.633138,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.742888);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00719077, 0, 1, 0.958721,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.848016,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418205,-99) , 
9, 0.356281, 0, 0, 0.555466,-99) , 
8, 0.0195527, 1, 0, 0.643284,-99) , 
6, 0.00531736, 0, 0, 0.786182,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.826385,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.267006,-99) , 
3, 472.669, 0, 0, 0.434685,-99) , 
8, 0.201272, 1, 0, 0.693111,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.504509);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.753441,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42808,-99) , 
5, 3.83919, 1, 0, 0.713256,-99) , 
0, 2.80619, 0, 0, 0.756248,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.3508,-99) , 
1, 4.95297, 1, 0, 0.72479,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460913,-99) , 
2, 174.035, 1, 0, 0.690388,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.524501);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0.153992, 0, 1, 0.786226,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.831981,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.410466,-99) , 
1, 1.48721, 1, 0, 0.580077,-99) , 
9, 0.264765, 1, 0, 0.679483,-99) , 
1, 3.15952, 0, 0, 0.731103,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.3691,-99) , 
9, 0.448333, 0, 0, 0.490051,-99) , 
6, 0.00531643, 1, 0, 0.613618,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.328559);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.914366,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478945,-99) , 
6, 0.000498605, 0, 0, 0.764857,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.808813,-99) , 
NN(
NN(
0, 
0, 
-1, 0.390614, 1, 1, 0.683591,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.76134,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409942,-99) , 
4, 1.15536, 0, 0, 0.454258,-99) , 
4, 2.24814, 0, 0, 0.49373,-99) , 
9, 0.754473, 0, 0, 0.519397,-99) , 
6, 0.00192981, 1, 0, 0.553568,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.649595);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.79987, 1, 1, 0.976722,-99) , 
NN(
NN(
0, 
0, 
-1, 0.00579382, 1, 1, 0.848845,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.781757,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.196581,-99) , 
1, 2.33284, 1, 0, 0.595456,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.333351,-99) , 
6, 0.0062849, 1, 0, 0.47049,-99) , 
0, 2.80622, 0, 0, 0.526816,-99) , 
8, 0.198368, 0, 0, 0.600798,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.425201);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.3842, 0, 1, 0.728698,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.679108,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.198493,-99) , 
0, 3.77058, 0, 0, 0.40383,-99) , 
1, 4.14206, 1, 0, 0.658095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431068,-99) , 
1, 1.21632, 0, 0, 0.613159,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.487148);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 2.07007, 1, 1, 0.772886,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.774923,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.374608,-99) , 
0, 1.56139, 0, 0, 0.51985,-99) , 
6, 0.00435126, 0, 0, 0.657194,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.279022,-99) , 
9, 0.907798, 1, 0, 0.601046,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.837408,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.34442,-99) , 
1, 4.99603, 1, 0, 0.494445,-99) , 
NN(
0, 
0, 
-1, 3.02123, 1, -1, 0.273521,-99) , 
1, 4.26145, 0, 0, 0.394868,-99) , 
1, 3.31276, 1, 0, 0.54639,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.295411);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.889026,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.859177,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.785909,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481478,-99) , 
7, 18.7035, 0, 0, 0.558567,-99) , 
9, 0.252893, 1, 0, 0.643114,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472747,-99) , 
9, 0.142053, 0, 0, 0.588579,-99) , 
7, 261.522, 0, 0, 0.615346,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.66226);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.418509, 1, 1, 0.858125,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 2.8444, 0, 1, 0.743622,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579231,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.229658,-99) , 
0, 3.31016, 1, 0, 0.412255,-99) , 
5, 0.709196, 0, 0, 0.564225,-99) , 
5, 3.66225, 0, 0, 0.616515,-99) , 
0, 1.67748, 1, 0, 0.719168,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.374541);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.906333,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.918711,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469499,-99) , 
6, 0.003818, 1, 0, 0.560392,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.912263,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.364609,-99) , 
1, 2.83038, 1, 0, 0.555419,-99) , 
NN(
0, 
0, 
-1, 4.08086, 1, -1, 0.301661,-99) , 
1, 1.94038, 0, 0, 0.362854,-99) , 
9, 0.295497, 1, 0, 0.450156,-99) , 
1, 4.23924, 0, 0, 0.47943,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.413067);
  fForest.push_back( 
NN(
0, 
0, 
-1, 0.142229, 1, 1, 0.695537,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.425851);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.699729,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419992,-99) , 
1, 3.9969, 1, 0, 0.653506,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.308133,-99) , 
6, 0.00231948, 0, 0, 0.60997,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.348243,-99) , 
8, 0.707283, 1, 0, 0.567922,-99) , 
6, 0.00144659, 1, 0, 0.600322,-99)    );
   return;
};

// Clean up
inline void ReadBDTs4::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDTs4::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}

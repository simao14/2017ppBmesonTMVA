// Class: ReadBDTs4
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTs4
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.22/01       [398849]
Creator        : tasheng
Date           : Fri Feb 24 23:50:38 2023
Host           : Linux GRENDEL01.MIT.EDU 3.10.0-957.21.3.el7.x86_64 #1 SMP Tue Jun 18 16:35:19 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/tasheng/bmva_nom/bmva_trk5/TMVA/Bs/train
Training events: 24001
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "4" [Max depth of the decision tree allowed]
MinNodeSize: "5.0%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "30" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
BaggedSampleFraction: "5.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "5.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 10
Btrk1Pt                       Btrk1Pt                       Btrk1Pt                       Btrk1Pt                                                         'F'    [1.00000751019,5.88283920288]
Btrk2Pt                       Btrk2Pt                       Btrk2Pt                       Btrk2Pt                                                         'F'    [1.00027012825,5.74269151688]
abs(Btrk1Dz1/Btrk1DzError1)   Trk1DCAz                      Trk1DCAz                      Trk1DCAz                                                        'F'    [0.00026452462771,5989.46972656]
abs(Btrk2Dz1/Btrk2DzError1)   Trk2DCAz                      Trk2DCAz                      Trk2DCAz                                                        'F'    [0.0002237912704,5860.21777344]
abs(Btrk1Dxy1/Btrk1DxyError1) Trk1DCAxy                     Trk1DCAxy                     Trk1DCAxy                                                       'F'    [3.6819052184e-05,90.350402832]
abs(Btrk2Dxy1/Btrk2DxyError1) Trk2DCAxy                     Trk2DCAxy                     Trk2DCAxy                                                       'F'    [8.56991318869e-05,83.982460022]
abs(Btktkmass-1.019455)       MassDis                       MassDis                       MassDis                                                         'F'    [1.63154595612e-07,0.0149930277839]
BsvpvDistance/BsvpvDisErr     dls                           dls                           dls                                                             'F'    [2.00044202805,8556.48632812]
Balpha                        Balpha                        Balpha                        Balpha                                                          'F'    [0.000169811435626,3.10385942459]
Bchi2cl                       Bchi2cl                       Bchi2cl                       Bchi2cl                                                         'F'    [0.0500244051218,0.999980330467]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDTs4Node

#ifndef BDTs4Node__def
#define BDTs4Node__def

class BDTs4Node {

public:

   // constructor of an essentially "empty" node floating in space
   BDTs4Node ( BDTs4Node* left,BDTs4Node* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTs4Node();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTs4Node* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTs4Node* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTs4Node*   fLeft;     // pointer to the left daughter node
   BDTs4Node*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDTs4Node::~BDTs4Node()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDTs4Node::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] >= fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDTs4Node::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTs4 : public IClassifierReader {

 public:

   // constructor
   ReadBDTs4( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDTs4" ),
        fNvars( 10 )
   {
      // the training input variables
      const char* inputVars[] = { "Btrk1Pt", "Btrk2Pt", "abs(Btrk1Dz1/Btrk1DzError1)", "abs(Btrk2Dz1/Btrk2DzError1)", "abs(Btrk1Dxy1/Btrk1DxyError1)", "abs(Btrk2Dxy1/Btrk2DxyError1)", "abs(Btktkmass-1.019455)", "BsvpvDistance/BsvpvDisErr", "Balpha", "Bchi2cl" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTs4() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[10];
   double fVmax[10];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[10];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTs4Node*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTs4::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTs4Node *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTs4Node*)current->GetRight();
         else current=(BDTs4Node*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDTs4::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(0.785703368956786);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.91528, 0, 1, 0.840388,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.908869,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.880901,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.309177,-99) , 
7, 11.1266, 0, 0, 0.424322,-99) , 
NN(
0, 
0, 
-1, 1.64648, 0, -1, 0.132005,-99) , 
8, 0.100003, 1, 0, 0.248008,-99) , 
1, 2.53028, 0, 0, 0.310509,-99) , 
5, 2.62876, 0, 0, 0.483802,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.711562);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.601638, 0, 1, 0.84981,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409931,-99) , 
6, 0.00773139, 1, 0, 0.772556,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.807546,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.375381,-99) , 
9, 0.448546, 0, 0, 0.553935,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.130431,-99) , 
6, 0.00385632, 1, 0, 0.285356,-99) , 
8, 0.100149, 1, 0, 0.539451,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.653006);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.233918, 0, 1, 0.811669,-99) , 
NN(
NN(
0, 
0, 
-1, 0.00288171, 1, 1, 0.780181,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.669116,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.369689,-99) , 
6, 0.000919852, 0, 0, 0.483897,-99) , 
NN(
0, 
0, 
-1, 2.05384, 0, -1, 0.180693,-99) , 
6, 0.00236883, 1, 0, 0.259199,-99) , 
4, 1.41901, 0, 0, 0.376233,-99) , 
5, 2.70967, 0, 0, 0.512425,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.454767);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.866595, 1, 1, 0.763345,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498931,-99) , 
9, 0.172599, 0, 0, 0.710569,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.915594,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491497,-99) , 
4, 1.62998, 0, 0, 0.69257,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.627899,-99) , 
NN(
0, 
0, 
-1, 1.60598, 0, -1, 0.261063,-99) , 
9, 0.693384, 0, 0, 0.330486,-99) , 
6, 0.00193293, 1, 0, 0.418317,-99) , 
0, 1.93079, 0, 0, 0.521213,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.532257);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.03498, 0, 1, 0.842647,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373783,-99) , 
9, 0.908016, 1, 0, 0.741432,-99) , 
NN(
NN(
0, 
0, 
-1, 0.00641286, 1, 1, 0.773961,-99) , 
NN(
NN(
0, 
0, 
-1, 6.27664, 1, 1, 0.599091,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.261827,-99) , 
5, 2.13855, 0, 0, 0.376138,-99) , 
0, 2.26013, 0, 0, 0.454717,-99) , 
6, 0.00290213, 1, 0, 0.571781,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.477861);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 6.38046, 0, 1, 0.732241,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.800176,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373558,-99) , 
6, 0.00140493, 1, 0, 0.483779,-99) , 
1, 1.45733, 0, 0, 0.641155,-99) , 
NN(
NN(
0, 
0, 
-1, 1.70386, 0, 1, 0.684314,-99) , 
NN(
0, 
0, 
-1, 2.033, 0, -1, 0.241433,-99) , 
9, 0.509556, 0, 0, 0.367917,-99) , 
6, 0.00435284, 1, 0, 0.518184,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.504554);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.783026,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.754797,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.221275,-99) , 
5, 7.10901, 1, 0, 0.629449,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.666795,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.318184,-99) , 
9, 0.662859, 0, 0, 0.396673,-99) , 
5, 1.14193, 0, 0, 0.521891,-99) , 
5, 8.85545, 0, 0, 0.548756,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.246821,-99) , 
6, 0.00966456, 1, 0, 0.498231,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.503348);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 1.43276, 0, 1, 0.726198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.302501,-99) , 
0, 1.83741, 1, 0, 0.599866,-99) , 
0, 1.99872, 0, 0, 0.717388,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 1.61143, 0, 1, 0.729941,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.384058,-99) , 
5, 1.84734, 1, 0, 0.590861,-99) , 
NN(
0, 
0, 
-1, 1.72891, 0, -1, 0.288475,-99) , 
8, 0.0997367, 1, 0, 0.420479,-99) , 
4, 2.55486, 0, 0, 0.516941,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.433634);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.540319, 0, 1, 0.849634,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 2.01035, 0, 1, 0.703454,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.605436,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.356991,-99) , 
1, 1.4855, 0, 0, 0.48058,-99) , 
6, 0.00289948, 1, 0, 0.568718,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.283189,-99) , 
8, 0.799858, 1, 0, 0.51016,-99) , 
0, 2.26009, 0, 0, 0.577528,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.447083);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.0996473, 1, 1, 0.752963,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.95571,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.792135,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.382006,-99) , 
0, 1.67911, 1, 0, 0.486952,-99) , 
6, 0.003633, 1, 0, 0.610449,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.691056,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439586,-99) , 
1, 1.90326, 0, 0, 0.518137,-99) , 
NN(
0, 
0, 
-1, 0.826016, 0, -1, 0.26151,-99) , 
9, 0.509677, 1, 0, 0.370621,-99) , 
4, 2.22468, 0, 0, 0.453297,-99) , 
6, 0.00145019, 1, 0, 0.505212,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.413495);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 2.84863, 1, 1, 0.950215,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.757698,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469664,-99) , 
5, 1.69213, 0, 0, 0.587001,-99) , 
9, 0.387148, 0, 0, 0.765277,-99) , 
NN(
NN(
0, 
0, 
-1, 0.540477, 1, 1, 0.669308,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534202,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.349627,-99) , 
9, 0.448303, 0, 0, 0.434173,-99) , 
0, 1.75971, 1, 0, 0.54926,-99) , 
0, 2.00875, 0, 0, 0.64392,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.638075,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.395205,-99) , 
0, 1.11417, 0, 0, 0.505447,-99) , 
NN(
0, 
0, 
-1, 0.00193293, 0, -1, 0.272454,-99) , 
0, 1.23612, 1, 0, 0.350193,-99) , 
0, 1.45754, 0, 0, 0.520241,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.466804);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00289472, 1, 1, 0.849785,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462076,-99) , 
8, 0.699979, 1, 0, 0.777879,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.790057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45201,-99) , 
6, 0.00387035, 1, 0, 0.592489,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.664713,-99) , 
NN(
0, 
0, 
-1, 0.632469, 0, -1, 0.305387,-99) , 
5, 4.22214, 0, 0, 0.356535,-99) , 
0, 1.58927, 0, 0, 0.430234,-99) , 
1, 1.76518, 0, 0, 0.553045,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.330341);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00386331, 1, 1, 0.845956,-99) , 
NN(
NN(
0, 
0, 
-1, 0.612536, 0, 1, 0.596106,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.664395,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.209776,-99) , 
9, 0.695563, 1, 0, 0.371324,-99) , 
5, 3.85744, 1, 0, 0.548598,-99) , 
4, 6.29745, 0, 0, 0.58772,-99) , 
NN(
0, 
0, 
-1, 0.0944987, 0, -1, 0.329163,-99) , 
9, 0.141952, 0, 0, 0.533747,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.475135);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 2.40147, 1, 1, 0.936075,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.785981,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.383996,-99) , 
0, 3.03228, 1, 0, 0.643747,-99) , 
4, 2.03135, 0, 0, 0.757405,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412731,-99) , 
6, 0.00821495, 1, 0, 0.66806,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.380397,-99) , 
7, 8.91977, 0, 0, 0.588537,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.277645,-99) , 
2, 9.84305, 1, 0, 0.502798,-99) , 
NN(
0, 
0, 
-1, 1.52747, 0, -1, 0.335012,-99) , 
8, 0.100289, 1, 0, 0.421501,-99) , 
1, 1.76204, 0, 0, 0.512917,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.409583);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.208099, 0, 1, 0.736406,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.698947,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.316528,-99) , 
5, 4.30817, 1, 0, 0.60319,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.27858,-99) , 
5, 7.42316, 1, 0, 0.511609,-99) , 
9, 0.540324, 1, 0, 0.621987,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591491,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.349393,-99) , 
4, 4.1978, 0, 0, 0.390034,-99) , 
6, 0.00677113, 1, 0, 0.547815,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.362673);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.910063,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 1.43944, 0, 1, 0.81087,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.753791,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444662,-99) , 
9, 0.754741, 0, 0, 0.486985,-99) , 
6, 0.00290213, 1, 0, 0.581747,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.340319,-99) , 
8, 1.40187, 1, 0, 0.536766,-99) , 
1, 2.68308, 0, 0, 0.569264,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.268384);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.836845,-99) , 
NN(
NN(
0, 
0, 
-1, 1.91246, 0, 1, 0.569204,-99) , 
NN(
0, 
0, 
-1, 2.66007, 0, -1, 0.330934,-99) , 
1, 2.34437, 1, 0, 0.521472,-99) , 
0, 2.76848, 0, 0, 0.547159,-99) , 
5, 9.89718, 0, 0, 0.572293,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.412232);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.41825, 0, 1, 0.846477,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.879781,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.688094,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413705,-99) , 
6, 0.00750113, 1, 0, 0.529647,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587646,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.291059,-99) , 
1, 1.48845, 1, 0, 0.370997,-99) , 
6, 0.00338368, 0, 0, 0.448662,-99) , 
1, 2.68152, 0, 0, 0.480529,-99) , 
5, 4.94873, 0, 0, 0.532726,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.39415);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.91782,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.927622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492817,-99) , 
4, 8.88909, 1, 0, 0.765513,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.802465,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441609,-99) , 
6, 0.00241907, 1, 0, 0.514117,-99) , 
8, 0.0195461, 1, 0, 0.607637,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551348,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.325715,-99) , 
5, 1.61644, 0, 0, 0.371919,-99) , 
8, 0.100165, 1, 0, 0.513019,-99) , 
2, 193.209, 0, 0, 0.55536,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.285142);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 1.44283, 0, 1, 0.678496,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553044,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.337584,-99) , 
9, 0.494724, 1, 0, 0.514251,-99) , 
9, 0.601603, 0, 0, 0.558298,-99) , 
5, 8.12902, 0, 0, 0.59013,-99) , 
NN(
0, 
0, 
-1, 3.39849, 1, -1, 0.297152,-99) , 
6, 0.000483804, 0, 0, 0.554083,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.348476);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.00290027, 0, 1, 0.852354,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0.20764, 0, 1, 0.663751,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445211,-99) , 
8, 1.29399, 1, 0, 0.625373,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389222,-99) , 
1, 1.15343, 0, 0, 0.589252,-99) , 
9, 0.816118, 0, 0, 0.623941,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.290823);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.693584, 1, 1, 0.840463,-99) , 
NN(
NN(
0, 
0, 
-1, 2.21062, 0, 1, 0.785086,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.772927,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481272,-99) , 
4, 1.98643, 0, 0, 0.533869,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.296742,-99) , 
5, 3.38908, 1, 0, 0.497308,-99) , 
1, 2.35864, 0, 0, 0.535181,-99) , 
5, 5.25688, 0, 0, 0.574342,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.224775);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.845004,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.788997,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.658316,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459076,-99) , 
6, 0.0059253, 0, 0, 0.490377,-99) , 
9, 0.816093, 0, 0, 0.527296,-99) , 
1, 2.66626, 0, 0, 0.551341,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.379588,-99) , 
6, 0.0091894, 1, 0, 0.508261,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.415225);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.356895, 0, 1, 0.79679,-99) , 
NN(
NN(
0, 
0, 
-1, 0.00569923, 1, 1, 0.692064,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.642133,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.304979,-99) , 
6, 0.00360767, 0, 0, 0.498124,-99) , 
9, 0.662807, 1, 0, 0.624782,-99) , 
6, 0.00192849, 1, 0, 0.660656,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.793625,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428782,-99) , 
1, 1.26466, 0, 0, 0.57746,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.278176,-99) , 
1, 1.68262, 1, 0, 0.467793,-99) , 
0, 1.46577, 0, 0, 0.57565,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.33429);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.116378, 0, 1, 0.73345,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462819,-99) , 
8, 0.600884, 1, 0, 0.669638,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399582,-99) , 
6, 0.00822212, 1, 0, 0.588744,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.328342);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.8538, 1, 1, 0.778916,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.790631,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.804859,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48105,-99) , 
5, 4.17016, 1, 0, 0.676337,-99) , 
NN(
0, 
0, 
-1, 0.00628223, 1, -1, 0.412315,-99) , 
2, 1.83771, 0, 0, 0.509565,-99) , 
2, 14.2342, 0, 0, 0.533821,-99) , 
2, 150.215, 0, 0, 0.566338,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.346982);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.418882, 1, 1, 0.756264,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49621,-99) , 
9, 0.141951, 0, 0, 0.694569,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43158,-99) , 
8, 1.09846, 1, 0, 0.633894,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.329263);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.76433, 0, 1, 0.774266,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0.000841835, 0, 1, 0.768994,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585375,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.328656,-99) , 
6, 0.00112316, 1, 0, 0.412491,-99) , 
9, 0.570961, 1, 0, 0.555348,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560649,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.353313,-99) , 
0, 1.31507, 0, 0, 0.483719,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.32418,-99) , 
9, 0.203318, 0, 0, 0.430042,-99) , 
6, 0.0029023, 1, 0, 0.468005,-99) , 
2, 164.206, 0, 0, 0.505747,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.278893);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.881622,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.767245,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542322,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.315708,-99) , 
4, 5.36513, 1, 0, 0.514483,-99) , 
9, 0.816088, 0, 0, 0.541707,-99) , 
3, 378.08, 0, 0, 0.56737,-99) , 
5, 7.4229, 0, 0, 0.601537,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.441041);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.69667, 1, 1, 0.873699,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0.099727, 1, 1, 0.767405,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.377976,-99) , 
6, 0.00144989, 0, 0, 0.649461,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630629,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460339,-99) , 
0, 2.05562, 1, 0, 0.580468,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.322365,-99) , 
4, 0.856952, 0, 0, 0.434155,-99) , 
5, 1.05185, 0, 0, 0.524556,-99) , 
4, 4.44456, 0, 0, 0.576297,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.329805);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 1.75754, 0, 1, 0.798332,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647704,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.392908,-99) , 
0, 2.91094, 1, 0, 0.599012,-99) , 
4, 2.03135, 0, 0, 0.663108,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.391809,-99) , 
9, 0.938654, 1, 0, 0.639198,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.675249,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420868,-99) , 
6, 0.00241969, 1, 0, 0.469674,-99) , 
0, 1.31507, 0, 0, 0.591076,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.331659);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.693522, 1, 1, 0.727137,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.641718,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415913,-99) , 
6, 0.00192849, 0, 0, 0.562924,-99) , 
8, 0.0967694, 1, 0, 0.642017,-99) , 
NN(
NN(
0, 
0, 
-1, 1.30485, 1, 1, 0.721563,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.380241,-99) , 
4, 1.8438, 0, 0, 0.465987,-99) , 
0, 1.47258, 0, 0, 0.561278,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.356387);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.872916,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.947016,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471554,-99) , 
9, 0.119241, 0, 0, 0.778351,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43006,-99) , 
6, 0.00576761, 1, 0, 0.597384,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.955004,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424265,-99) , 
9, 0.713313, 1, 0, 0.507268,-99) , 
NN(
0, 
0, 
-1, 0.552806, 1, -1, 0.347759,-99) , 
9, 0.613532, 0, 0, 0.442805,-99) , 
9, 0.479035, 1, 0, 0.513251,-99) , 
1, 2.68306, 0, 0, 0.533123,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.382223);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00290242, 1, 1, 0.865603,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.649426,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414543,-99) , 
1, 1.49848, 1, 0, 0.531897,-99) , 
0, 1.4664, 0, 0, 0.700959,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.836261,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.615078,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.681079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.349889,-99) , 
2, 8.59314, 0, 0, 0.379873,-99) , 
9, 0.121198, 1, 0, 0.43046,-99) , 
2, 268.548, 0, 0, 0.466015,-99) , 
9, 0.601623, 0, 0, 0.5258,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.325484);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.38105, 1, 1, 0.688423,-99) , 
NN(
NN(
0, 
0, 
-1, 0.0996473, 1, 1, 0.640455,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608862,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.346338,-99) , 
1, 2.38228, 1, 0, 0.51255,-99) , 
NN(
0, 
0, 
-1, 0.601771, 1, -1, 0.315351,-99) , 
6, 0.00363555, 0, 0, 0.459871,-99) , 
6, 0.0024186, 1, 0, 0.505732,-99) , 
0, 1.47254, 1, 0, 0.568312,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.302652);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.801401,-99) , 
NN(
NN(
0, 
0, 
-1, 0.916999, 1, 1, 0.692784,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602276,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413563,-99) , 
9, 0.47705, 1, 0, 0.517026,-99) , 
NN(
0, 
0, 
-1, 0.00688176, 0, -1, 0.350677,-99) , 
6, 0.00532021, 1, 0, 0.438189,-99) , 
9, 0.785474, 0, 0, 0.473536,-99) , 
0, 1.15529, 1, 0, 0.504415,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.39894);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.943775,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.759628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401172,-99) , 
5, 3.12747, 1, 0, 0.695221,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45107,-99) , 
8, 0.29847, 1, 0, 0.618891,-99) , 
5, 4.8484, 0, 0, 0.660971,-99) , 
NN(
NN(
0, 
0, 
-1, 1.46732, 1, 1, 0.675039,-99) , 
NN(
0, 
0, 
-1, 1.33037, 0, -1, 0.343028,-99) , 
9, 0.509654, 1, 0, 0.476157,-99) , 
1, 1.45733, 0, 0, 0.580928,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.351355);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.883882,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.8067,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425773,-99) , 
6, 0.00523122, 0, 0, 0.481495,-99) , 
9, 0.79437, 1, 0, 0.598852,-99) , 
6, 0.00289565, 1, 0, 0.69402,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.650303,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.651744,-99) , 
NN(
0, 
0, 
-1, 3.43229, 0, -1, 0.356475,-99) , 
6, 0.00162196, 1, 0, 0.416081,-99) , 
6, 0.00628699, 0, 0, 0.487716,-99) , 
9, 0.6016, 0, 0, 0.547872,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.365715);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.233937, 0, 1, 0.695318,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.771199,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.645193,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.374988,-99) , 
6, 0.0019342, 0, 0, 0.568604,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578995,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.277359,-99) , 
1, 2.27045, 0, 0, 0.395525,-99) , 
1, 1.90505, 1, 0, 0.497383,-99) , 
4, 0.329604, 1, 0, 0.536659,-99) , 
4, 2.55489, 0, 0, 0.578659,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.377879);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.818948,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441047,-99) , 
9, 0.693701, 1, 0, 0.636875,-99) , 
6, 0.00338099, 0, 0, 0.789428,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.82985,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.654741,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461536,-99) , 
0, 1.40645, 0, 0, 0.559968,-99) , 
5, 1.9501, 0, 0, 0.590516,-99) , 
NN(
0, 
0, 
-1, 0.848743, 0, -1, 0.303285,-99) , 
1, 2.47506, 1, 0, 0.533155,-99) , 
5, 2.62876, 0, 0, 0.591592,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.329351);
  fForest.push_back( 
NN(
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.712902,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492945,-99) , 
6, 0.000483804, 0, 0, 0.687339,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577865,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.27938,-99) , 
1, 3.02646, 0, 0, 0.431671,-99) , 
1, 2.73562, 1, 0, 0.64099,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574637,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.346286,-99) , 
0, 1.30961, 1, 0, 0.44101,-99) , 
1, 1.30593, 0, 0, 0.57126,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.348873,-99) , 
9, 0.111334, 0, 0, 0.537331,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.384786);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.000700529, 0, 1, 0.741173,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.786904,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.614513,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.356708,-99) , 
9, 0.663909, 0, 0, 0.478535,-99) , 
4, 2.13117, 0, 0, 0.558961,-99) , 
9, 0.479245, 1, 0, 0.634398,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.761776,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.583353,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.310292,-99) , 
9, 0.448271, 0, 0, 0.398518,-99) , 
0, 2.21221, 0, 0, 0.447535,-99) , 
6, 0.00434684, 1, 0, 0.532533,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.257723);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.866684,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.751396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496766,-99) , 
6, 0.00344999, 0, 0, 0.590885,-99) , 
6, 0.000748174, 1, 0, 0.626491,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425375,-99) , 
6, 0.00773151, 1, 0, 0.556543,-99) , 
NN(
0, 
0, 
-1, 0.00240777, 1, -1, 0.328112,-99) , 
9, 0.141952, 0, 0, 0.499306,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.288475);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.109349, 0, 1, 0.708652,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432041,-99) , 
0, 1.30036, 0, 0, 0.618171,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.802967,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493453,-99) , 
9, 0.558948, 1, 0, 0.536071,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.168669,-99) , 
4, 12.7594, 1, 0, 0.478959,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.206817,-99) , 
9, 0.474097, 0, 0, 0.433363,-99) , 
9, 0.417752, 1, 0, 0.507962,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.405899);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.172654, 0, 1, 0.755348,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.73084,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.774134,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44653,-99) , 
1, 1.9205, 0, 0, 0.544898,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.218444,-99) , 
4, 1.91708, 0, 0, 0.285199,-99) , 
4, 1.39705, 1, 0, 0.438072,-99) , 
0, 1.30301, 1, 0, 0.498769,-99) , 
4, 2.55486, 0, 0, 0.549593,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.364427);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.954384,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.717866,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494509,-99) , 
6, 0.00193457, 0, 0, 0.646666,-99) , 
9, 0.816118, 0, 0, 0.679738,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.392253,-99) , 
1, 2.83605, 1, 0, 0.645427,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.323438,-99) , 
8, 2.29927, 1, 0, 0.566116,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.327891);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 6.40437, 1, 1, 0.781444,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.814504,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608045,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476735,-99) , 
9, 0.612509, 0, 0, 0.519577,-99) , 
1, 1.83648, 0, 0, 0.584586,-99) , 
8, 0.0996934, 1, 0, 0.676025,-99) , 
NN(
0, 
0, 
-1, 0.0915337, 0, -1, 0.432553,-99) , 
9, 0.141946, 0, 0, 0.614389,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.270886);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.68634, 0, 1, 0.809652,-99) , 
NN(
NN(
0, 
0, 
-1, 0.785474, 0, 1, 0.616889,-99) , 
NN(
0, 
0, 
-1, 5.15899, 1, -1, 0.42879,-99) , 
1, 1.30593, 0, 0, 0.549149,-99) , 
2, 164.207, 0, 0, 0.588727,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.360871);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.655979, 1, 1, 0.70064,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404243,-99) , 
9, 0.111333, 0, 0, 0.641254,-99) , 
NN(
0, 
0, 
-1, 0.724177, 1, -1, 0.370318,-99) , 
0, 2.89014, 1, 0, 0.60526,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.315602);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.935216,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450492,-99) , 
9, 0.203297, 0, 0, 0.711535,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.86871,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.614155,-99) , 
NN(
0, 
0, 
-1, 1.55796, 1, -1, 0.394196,-99) , 
9, 0.23391, 1, 0, 0.445911,-99) , 
4, 0.283717, 1, 0, 0.481583,-99) , 
4, 2.91623, 0, 0, 0.523045,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.215683);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0.816118, 0, 1, 0.581303,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432272,-99) , 
8, 1.20165, 1, 0, 0.54531,-99) , 
1, 2.67616, 0, 0, 0.57567,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.431395);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.81509, 1, 1, 0.822207,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.798404,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.606579,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413873,-99) , 
5, 1.11753, 1, 0, 0.521255,-99) , 
5, 2.30331, 0, 0, 0.572451,-99) , 
0, 1.57085, 0, 0, 0.628765,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.830572,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.321457,-99) , 
5, 3.85871, 1, 0, 0.630467,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.740453,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.323866,-99) , 
9, 0.545283, 0, 0, 0.534544,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.225695,-99) , 
1, 1.67753, 0, 0, 0.413515,-99) , 
9, 0.295174, 1, 0, 0.487698,-99) , 
0, 1.93146, 1, 0, 0.575665,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.281258);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00749777, 1, 1, 0.662362,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.667412,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541122,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.381284,-99) , 
9, 0.417383, 1, 0, 0.452815,-99) , 
1, 3.03876, 0, 0, 0.485434,-99) , 
0, 1.94519, 1, 0, 0.589937,-99) , 
NN(
0, 
0, 
-1, 3.13592, 1, -1, 0.352998,-99) , 
6, 0.0004835, 0, 0, 0.557827,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.267227);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.811093,-99) , 
NN(
NN(
0, 
0, 
-1, 0.00365982, 1, 1, 0.606477,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572056,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.230054,-99) , 
0, 2.24314, 1, 0, 0.43216,-99) , 
6, 0.00199425, 0, 0, 0.528135,-99) , 
9, 0.81613, 0, 0, 0.557052,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402921,-99) , 
6, 0.00773159, 1, 0, 0.507941,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.330314);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.27872, 0, 1, 0.715889,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.682991,-99) , 
NN(
0, 
0, 
-1, 0.0083629, 0, -1, 0.366106,-99) , 
0, 2.37264, 0, 0, 0.400242,-99) , 
6, 0.00290201, 1, 0, 0.483442,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.284037);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.824375,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468067,-99) , 
8, 1.67663, 0, 0, 0.689548,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.756353,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.710999,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421615,-99) , 
2, 5.24485, 0, 0, 0.455761,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.204533,-99) , 
5, 4.28918, 1, 0, 0.426223,-99) , 
5, 6.33193, 0, 0, 0.446972,-99) , 
2, 164.207, 0, 0, 0.480011,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.315574);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.25517, 1, 1, 0.678375,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.724568,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494767,-99) , 
1, 1.46013, 0, 0, 0.620609,-99) , 
NN(
0, 
0, 
-1, 1.6122, 1, -1, 0.396388,-99) , 
6, 0.00222846, 1, 0, 0.482223,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.247195,-99) , 
8, 1.99939, 1, 0, 0.432777,-99) , 
6, 0.00531535, 0, 0, 0.507387,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.269533);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.847412,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.799381,-99) , 
NN(
NN(
0, 
0, 
-1, 1.35684, 0, 1, 0.604274,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530227,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.341871,-99) , 
9, 0.343678, 0, 0, 0.424844,-99) , 
1, 1.5818, 1, 0, 0.509181,-99) , 
0, 2.83024, 0, 0, 0.527762,-99) , 
9, 0.877372, 0, 0, 0.549905,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.24358);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.697457,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.681114,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.76067,-99) , 
NN(
0, 
0, 
-1, 9.26613, 1, -1, 0.407029,-99) , 
9, 0.877368, 0, 0, 0.428589,-99) , 
2, 143.657, 0, 0, 0.455962,-99) , 
1, 2.50756, 0, 0, 0.477901,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.289444);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.29823, 0, 1, 0.719179,-99) , 
NN(
NN(
0, 
0, 
-1, 1.85692, 0, 1, 0.577539,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.684658,-99) , 
NN(
0, 
0, 
-1, 0.602009, 0, -1, 0.338456,-99) , 
1, 2.2614, 0, 0, 0.448487,-99) , 
1, 1.75509, 1, 0, 0.521826,-99) , 
6, 0.00241837, 1, 0, 0.567852,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.398833);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.928618,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.730908,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.631186,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423065,-99) , 
0, 1.4509, 0, 0, 0.527122,-99) , 
9, 0.148868, 1, 0, 0.579794,-99) , 
5, 4.84823, 0, 0, 0.607123,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585189,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.787529,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.285387,-99) , 
1, 1.42457, 0, 0, 0.440748,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.142057,-99) , 
0, 1.70106, 1, 0, 0.31836,-99) , 
0, 1.94511, 0, 0, 0.376704,-99) , 
9, 0.662878, 1, 0, 0.52438,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.351937);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.465147, 0, 1, 0.759763,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.267316,-99) , 
9, 0.908022, 1, 0, 0.681885,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.638836,-99) , 
NN(
0, 
0, 
-1, 3.61638, 1, -1, 0.430551,-99) , 
9, 0.724186, 0, 0, 0.466449,-99) , 
1, 1.45735, 0, 0, 0.574912,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.298252);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.16823, 0, 1, 0.687162,-99) , 
NN(
NN(
0, 
0, 
-1, 0.762462, 1, 1, 0.690547,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.658441,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454589,-99) , 
6, 0.00531549, 1, 0, 0.549891,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528156,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.246696,-99) , 
1, 1.62571, 1, 0, 0.418807,-99) , 
1, 1.73649, 0, 0, 0.491757,-99) , 
8, 0.200488, 0, 0, 0.54512,-99) , 
1, 1.30654, 1, 0, 0.584433,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.311283);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.000545218, 0, 1, 0.72615,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.712257,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.673098,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43277,-99) , 
9, 0.464655, 0, 0, 0.485842,-99) , 
0, 2.17912, 0, 0, 0.517616,-99) , 
NN(
0, 
0, 
-1, 3.90979, 1, -1, 0.322686,-99) , 
9, 0.693513, 1, 0, 0.459014,-99) , 
6, 0.00241642, 1, 0, 0.519782,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.324105);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.00386657, 1, 1, 0.68914,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.800078,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46313,-99) , 
4, 2.03622, 1, 0, 0.651707,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.744818,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4244,-99) , 
1, 1.7088, 0, 0, 0.538349,-99) , 
NN(
0, 
0, 
-1, 1.87591, 0, -1, 0.366085,-99) , 
0, 1.61018, 1, 0, 0.424244,-99) , 
6, 0.00241514, 1, 0, 0.469832,-99) , 
1, 1.3021, 1, 0, 0.52934,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.410398);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.967296,-99) , 
NN(
NN(
0, 
0, 
-1, 2.03047, 0, 1, 0.670438,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.341485,-99) , 
6, 0.0004835, 0, 0, 0.63497,-99) , 
0, 2.39645, 0, 0, 0.668544,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.318421,-99) , 
8, 0.597888, 1, 0, 0.572222,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.203857);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.77167, 0, 1, 0.679701,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 2.83792, 0, 1, 0.55435,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.347386,-99) , 
5, 8.55158, 1, 0, 0.536806,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.615194,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.342661,-99) , 
7, 19.6991, 0, 0, 0.395063,-99) , 
9, 0.172599, 0, 0, 0.494083,-99) , 
2, 164.208, 0, 0, 0.518111,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.342454);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.891465,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.640141,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.307503,-99) , 
9, 0.718105, 1, 0, 0.580849,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.364076,-99) , 
8, 0.599976, 1, 0, 0.519336,-99) , 
9, 0.846766, 0, 0, 0.548854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.335959,-99) , 
6, 0.00918934, 1, 0, 0.491019,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.243279);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.66703, 1, 1, 0.653166,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.687041,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.641193,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503046,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.316797,-99) , 
0, 1.74755, 1, 0, 0.414686,-99) , 
0, 2.37705, 0, 0, 0.445679,-99) , 
0, 1.15752, 1, 0, 0.475033,-99) , 
8, 0.199896, 0, 0, 0.522955,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.363057);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.00675824, 1, 1, 0.734806,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0.540344, 1, 1, 0.824658,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529327,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.351697,-99) , 
0, 1.30061, 1, 0, 0.440644,-99) , 
0, 1.58244, 0, 0, 0.534311,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.341913,-99) , 
1, 1.6181, 1, 0, 0.491942,-99) , 
1, 1.76617, 0, 0, 0.562814,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.387352);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.40057, 1, 1, 0.744993,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.822385,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.681523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.306123,-99) , 
0, 2.02747, 1, 0, 0.373485,-99) , 
9, 0.142044, 1, 0, 0.43685,-99) , 
0, 1.62111, 1, 0, 0.528976,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587436,-99) , 
NN(
0, 
0, 
-1, 1.76237, 1, -1, 0.351408,-99) , 
4, 4.20035, 0, 0, 0.381217,-99) , 
1, 1.45951, 0, 0, 0.462205,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.269233);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.45953, 1, 1, 0.623316,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.769017,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476426,-99) , 
0, 1.79216, 0, 0, 0.648994,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523599,-99) , 
NN(
0, 
0, 
-1, 1.57238, 0, -1, 0.342875,-99) , 
0, 1.24792, 1, 0, 0.382991,-99) , 
1, 1.76439, 0, 0, 0.442811,-99) , 
6, 0.00483271, 0, 0, 0.513314,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.407259);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.0024152, 0, 1, 0.769309,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.940765,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.345602,-99) , 
6, 0.00193504, 0, 0, 0.655331,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.699308,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431872,-99) , 
9, 0.571083, 1, 0, 0.564256,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.345215,-99) , 
6, 0.00337069, 1, 0, 0.41181,-99) , 
0, 1.93111, 0, 0, 0.460757,-99) , 
4, 2.91456, 0, 0, 0.50772,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.357751);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.938013,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.623697,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.380471,-99) , 
6, 0.00289736, 0, 0, 0.541889,-99) , 
9, 0.724138, 0, 0, 0.599113,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.7841,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415366,-99) , 
4, 2.91562, 1, 0, 0.665624,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518382,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.284406,-99) , 
6, 0.00187274, 0, 0, 0.390305,-99) , 
9, 0.356459, 0, 0, 0.532233,-99) , 
NN(
0, 
0, 
-1, 2.15093, 0, -1, 0.326779,-99) , 
6, 0.00579897, 1, 0, 0.430949,-99) , 
1, 1.45967, 1, 0, 0.495564,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.306835);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.918641,-99) , 
NN(
NN(
0, 
0, 
-1, 1.80736, 0, 1, 0.616155,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.708187,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.671597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.395803,-99) , 
0, 1.35558, 1, 0, 0.447352,-99) , 
0, 2.57521, 0, 0, 0.483753,-99) , 
1, 1.45959, 1, 0, 0.538816,-99) , 
3, 378.079, 0, 0, 0.570782,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.310297);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.723707,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.865957,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464166,-99) , 
8, 0.757448, 1, 0, 0.572782,-99) , 
NN(
NN(
0, 
0, 
-1, 2.5662, 1, 1, 0.701473,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546821,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.335029,-99) , 
6, 0.00241738, 1, 0, 0.375646,-99) , 
1, 2.07115, 0, 0, 0.426563,-99) , 
8, 0.199146, 0, 0, 0.471582,-99) , 
5, 5.4183, 0, 0, 0.493402,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.247026);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.868282,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 1.22322, 0, 1, 0.656342,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515951,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.268348,-99) , 
0, 2.86154, 1, 0, 0.486146,-99) , 
6, 0.00483756, 0, 0, 0.556842,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.28576,-99) , 
9, 0.41758, 1, 0, 0.375551,-99) , 
4, 2.70673, 1, 0, 0.527629,-99) , 
4, 4.19783, 0, 0, 0.55897,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.237291);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.759367,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4613,-99) , 
0, 1.91117, 1, 0, 0.629106,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.703365,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553126,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.390337,-99) , 
0, 1.54019, 1, 0, 0.47374,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.251737,-99) , 
9, 0.741889, 1, 0, 0.44679,-99) , 
0, 2.39616, 0, 0, 0.468862,-99) , 
9, 0.81609, 0, 0, 0.488862,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.241873);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.807465,-99) , 
NN(
NN(
0, 
0, 
-1, 0.795198, 0, 1, 0.596486,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.359466,-99) , 
9, 0.938665, 1, 0, 0.57474,-99) , 
5, 5.41876, 0, 0, 0.595102,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.357485);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.75592,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471839,-99) , 
5, 4.73681, 1, 0, 0.580127,-99) , 
0, 1.57682, 1, 0, 0.699352,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.885027,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.810521,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403222,-99) , 
5, 1.16122, 0, 0, 0.499529,-99) , 
NN(
0, 
0, 
-1, 0.620771, 0, -1, 0.360834,-99) , 
9, 0.445489, 0, 0, 0.410604,-99) , 
9, 0.816137, 0, 0, 0.442942,-99) , 
5, 2.40539, 0, 0, 0.493118,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.285978);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.0995461, 1, 1, 0.747531,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.778876,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553422,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.326697,-99) , 
1, 2.21227, 1, 0, 0.506418,-99) , 
NN(
0, 
0, 
-1, 0.00480534, 1, -1, 0.359794,-99) , 
9, 0.402883, 1, 0, 0.45181,-99) , 
3, 334.929, 0, 0, 0.480104,-99) , 
9, 0.693543, 0, 0, 0.526128,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.344258);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.888417,-99) , 
NN(
NN(
0, 
0, 
-1, 5.4183, 1, 1, 0.760337,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575208,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.320083,-99) , 
6, 0.00385648, 0, 0, 0.447412,-99) , 
8, 0.0223665, 1, 0, 0.5124,-99) , 
8, 0.172596, 0, 0, 0.544799,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.36121,-99) , 
8, 0.596804, 1, 0, 0.496185,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.307922);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.8818,-99) , 
NN(
NN(
0, 
0, 
-1, 0.869532, 1, 1, 0.750994,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.652624,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416528,-99) , 
6, 0.00580361, 1, 0, 0.528993,-99) , 
9, 0.632266, 0, 0, 0.584126,-99) , 
1, 1.58931, 1, 0, 0.625999,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.675393,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415207,-99) , 
5, 1.81142, 0, 0, 0.482643,-99) , 
1, 1.45299, 0, 0, 0.561862,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.389252);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.965538,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.752579,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42285,-99) , 
6, 0.00406736, 0, 0, 0.636567,-99) , 
6, 0.00289807, 1, 0, 0.714954,-99) , 
NN(
NN(
0, 
0, 
-1, 1.3451, 0, 1, 0.602368,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.667962,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.289154,-99) , 
1, 1.75314, 0, 0, 0.408414,-99) , 
1, 1.4527, 1, 0, 0.50697,-99) , 
0, 1.76293, 0, 0, 0.575689,-99) , 
NN(
0, 
0, 
-1, 0.96445, 1, -1, 0.308659,-99) , 
9, 0.908016, 1, 0, 0.542571,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.273269);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.792694,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 1.66945, 0, 1, 0.708111,-99) , 
NN(
0, 
0, 
-1, 0.846709, 1, -1, 0.454264,-99) , 
1, 1.60561, 1, 0, 0.536928,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.354415,-99) , 
0, 1.312, 0, 0, 0.470188,-99) , 
4, 4.06662, 0, 0, 0.50217,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.384553);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.572356, 1, 1, 0.766144,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.907639,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.774085,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.353953,-99) , 
6, 0.00406882, 0, 0, 0.598087,-99) , 
6, 0.00289948, 1, 0, 0.69106,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.701388,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.408612,-99) , 
0, 1.94386, 0, 0, 0.456824,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.22202,-99) , 
0, 2.95235, 1, 0, 0.424781,-99) , 
9, 0.570961, 0, 0, 0.493158,-99) , 
2, 143.657, 0, 0, 0.532178,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.382425);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00579135, 1, 1, 0.725691,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.652468,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.384817,-99) , 
0, 1.17592, 1, 0, 0.517008,-99) , 
0, 1.28755, 0, 0, 0.643209,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.686482,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587196,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.620837,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.292892,-99) , 
1, 2.51131, 0, 0, 0.382619,-99) , 
8, 0.0706754, 0, 0, 0.421658,-99) , 
8, 0.199426, 0, 0, 0.470975,-99) , 
1, 1.90488, 1, 0, 0.584467,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.316855);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.57908, 0, 1, 0.740858,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.773441,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.701915,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.358947,-99) , 
9, 0.754808, 1, 0, 0.61201,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.696165,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412083,-99) , 
5, 1.95508, 0, 0, 0.449482,-99) , 
2, 1.6051, 0, 0, 0.500456,-99) , 
2, 9.9635, 0, 0, 0.523528,-99) , 
2, 154.673, 0, 0, 0.550929,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.289596);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.847613,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 1.98742, 0, 1, 0.600191,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.242497,-99) , 
5, 4.43665, 1, 0, 0.566624,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331492,-99) , 
5, 0.349696, 0, 0, 0.512625,-99) , 
5, 5.4184, 0, 0, 0.533345,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.368496);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.910134,-99) , 
NN(
NN(
0, 
0, 
-1, 0.356119, 0, 1, 0.753397,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591814,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.385438,-99) , 
1, 2.19714, 1, 0, 0.541976,-99) , 
9, 0.430119, 1, 0, 0.597193,-99) , 
9, 0.818066, 0, 0, 0.639578,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.658541,-99) , 
NN(
0, 
0, 
-1, 0.20536, 0, -1, 0.31303,-99) , 
9, 0.121138, 1, 0, 0.421908,-99) , 
9, 0.295162, 0, 0, 0.539815,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.332784);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0504478, 1, 1, 0.692407,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.621727,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.310705,-99) , 
6, 0.00369664, 1, 0, 0.544992,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.249783,-99) , 
6, 0.000282232, 0, 0, 0.485122,-99) , 
6, 0.00435351, 0, 0, 0.569505,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.375421,-99) , 
8, 0.797127, 1, 0, 0.517015,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.375687);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.18581, 0, 1, 0.835731,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.677388,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414765,-99) , 
0, 2.82015, 1, 0, 0.52571,-99) , 
0, 2.10195, 1, 0, 0.655955,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.682422,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.940223,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40756,-99) , 
6, 0.00290185, 1, 0, 0.510732,-99) , 
NN(
0, 
0, 
-1, 1.27159, 1, -1, 0.329631,-99) , 
0, 1.40503, 1, 0, 0.418695,-99) , 
0, 2.04742, 0, 0, 0.445317,-99) , 
1, 1.76468, 0, 0, 0.502684,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.279069);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.22233, 0, 1, 0.660278,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.387475,-99) , 
0, 1.15517, 0, 0, 0.603408,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406505,-99) , 
6, 0.0101307, 1, 0, 0.553855,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.222328);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.812791,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.764914,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584358,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436958,-99) , 
8, 0.0998231, 1, 0, 0.504318,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.294971,-99) , 
0, 2.32069, 1, 0, 0.490083,-99) , 
3, 502.396, 0, 0, 0.508721,-99) , 
0, 2.57511, 0, 0, 0.529827,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.29353);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.754946,-99) , 
NN(
NN(
0, 
0, 
-1, 1.61299, 0, 1, 0.669706,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.61943,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437105,-99) , 
6, 0.00403744, 1, 0, 0.473809,-99) , 
9, 0.509713, 0, 0, 0.536802,-99) , 
7, 233.718, 0, 0, 0.565445,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590386,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512616,-99) , 
NN(
0, 
0, 
-1, 0.335389, 0, -1, 0.227056,-99) , 
9, 0.570956, 0, 0, 0.296231,-99) , 
6, 0.000374548, 1, 0, 0.357608,-99) , 
6, 0.00193486, 0, 0, 0.503277,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.318673);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.285295, 0, 1, 0.68237,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.774949,-99) , 
NN(
0, 
0, 
-1, 0.369318, 1, -1, 0.426629,-99) , 
1, 2.25042, 0, 0, 0.511864,-99) , 
1, 1.59871, 1, 0, 0.597748,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.666292,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589207,-99) , 
NN(
0, 
0, 
-1, 1.38191, 1, -1, 0.329103,-99) , 
6, 0.00193743, 1, 0, 0.382072,-99) , 
1, 2.06707, 0, 0, 0.435181,-99) , 
9, 0.570968, 1, 0, 0.537194,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.362633);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.28962, 0, 1, 0.761572,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.804412,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436106,-99) , 
1, 1.45163, 0, 0, 0.585584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.284007,-99) , 
1, 2.16579, 1, 0, 0.521104,-99) , 
8, 0.0997111, 1, 0, 0.606853,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.398445,-99) , 
6, 0.00918934, 1, 0, 0.544369,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.321605);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 241.862, 1, 1, 0.855036,-99) , 
NN(
NN(
0, 
0, 
-1, 1.73788, 1, 1, 0.720625,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.711804,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437663,-99) , 
9, 0.876486, 0, 0, 0.463552,-99) , 
9, 0.233908, 1, 0, 0.529424,-99) , 
2, 24.9085, 0, 0, 0.571518,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.263992,-99) , 
2, 772.835, 1, 0, 0.535016,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.357193);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.96185,-99) , 
NN(
NN(
0, 
0, 
-1, 0.00386075, 1, 1, 0.658515,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569852,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.335575,-99) , 
9, 0.306895, 1, 0, 0.480213,-99) , 
9, 0.44839, 0, 0, 0.543226,-99) , 
4, 0.413809, 1, 0, 0.584562,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.177196,-99) , 
4, 12.7756, 1, 0, 0.551255,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.277798);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.719874,-99) , 
NN(
NN(
0, 
0, 
-1, 1.61253, 0, 1, 0.671406,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.782922,-99) , 
NN(
0, 
0, 
-1, 1.74688, 1, -1, 0.422376,-99) , 
1, 1.15512, 1, 0, 0.456724,-99) , 
8, 0.197612, 0, 0, 0.506533,-99) , 
6, 0.0096734, 0, 0, 0.549071,-99)    );
   return;
};

// Clean up
inline void ReadBDTs4::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDTs4::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}

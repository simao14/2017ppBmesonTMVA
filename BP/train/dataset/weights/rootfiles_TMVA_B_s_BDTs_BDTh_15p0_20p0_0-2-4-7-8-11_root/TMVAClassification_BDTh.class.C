// Class: ReadBDTh
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTh
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.22/01       [398849]
Creator        : tasheng
Date           : Sat Feb 25 00:07:31 2023
Host           : Linux GRENDEL01.MIT.EDU 3.10.0-957.21.3.el7.x86_64 #1 SMP Tue Jun 18 16:35:19 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/tasheng/bmva_nom/bmva_trk5/TMVA/BP/train
Training events: 20592
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "5.0%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "30" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
BaggedSampleFraction: "5.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "5.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 6
Btrk1Pt                       Btrk1Pt                       Btrk1Pt                       Btrk1Pt                                                         'F'    [0.500948786736,13.3480262756]
abs(Btrk1Dz1/Btrk1DzError1)   Trk1DCAz                      Trk1DCAz                      Trk1DCAz                                                        'F'    [0.000295490812277,8446.88867188]
abs(Btrk1Dxy1/Btrk1DxyError1) Trk1DCAxy                     Trk1DCAxy                     Trk1DCAxy                                                       'F'    [4.8405941925e-05,202.398910522]
BsvpvDistance/BsvpvDisErr     dls                           dls                           dls                                                             'F'    [2.00059986115,9633.15136719]
Balpha                        Balpha                        Balpha                        Balpha                                                          'F'    [0.000111724817543,3.13623476028]
Bchi2cl                       Bchi2cl                       Bchi2cl                       Bchi2cl                                                         'F'    [0.0500254072249,0.99999332428]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDThNode

#ifndef BDThNode__def
#define BDThNode__def

class BDThNode {

public:

   // constructor of an essentially "empty" node floating in space
   BDThNode ( BDThNode* left,BDThNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDThNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDThNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDThNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDThNode*   fLeft;     // pointer to the left daughter node
   BDThNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDThNode::~BDThNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDThNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] >= fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDThNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTh : public IClassifierReader {

 public:

   // constructor
   ReadBDTh( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDTh" ),
        fNvars( 6 )
   {
      // the training input variables
      const char* inputVars[] = { "Btrk1Pt", "abs(Btrk1Dz1/Btrk1DzError1)", "abs(Btrk1Dxy1/Btrk1DxyError1)", "BsvpvDistance/BsvpvDisErr", "Balpha", "Bchi2cl" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTh() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[6];
   double fVmax[6];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[6];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDThNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTh::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDThNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDThNode*)current->GetRight();
         else current=(BDThNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDTh::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(1.30873602187137);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.100353, 1, 1, 0.935187,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.873022,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0633362,-99) , 
2, 4.76005, 0, 0, 0.154463,-99) , 
0, 1.74465, 0, 0, 0.494527,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.878125);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.83749, 0, 1, 0.894808,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.790212,-99) , 
NN(
0, 
0, 
-1, 1.37946, 0, -1, 0.166938,-99) , 
2, 4.76005, 0, 0, 0.263102,-99) , 
0, 2.12823, 0, 0, 0.506039,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.714389);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.100353, 1, 1, 0.887021,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.901547,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494318,-99) , 
5, 0.38686, 0, 0, 0.698727,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54388,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.145424,-99) , 
2, 1.91564, 0, 0, 0.240606,-99) , 
2, 5.39578, 0, 0, 0.31613,-99) , 
0, 2.49862, 0, 0, 0.502346,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.785171);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.65911, 0, 1, 0.891526,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.961908,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.350362,-99) , 
1, 2.98016, 0, 0, 0.547501,-99) , 
NN(
0, 
0, 
-1, 3.12043, 0, -1, 0.134936,-99) , 
4, 0.101242, 1, 0, 0.343712,-99) , 
2, 5.39032, 0, 0, 0.478779,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.584291);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.0984086, 1, 1, 0.935828,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.916273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486855,-99) , 
1, 5.61146, 0, 0, 0.605534,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.199077,-99) , 
4, 0.101098, 1, 0, 0.435433,-99) , 
0, 2.9875, 0, 0, 0.571399,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.59697);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.70832, 0, 1, 0.95221,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.799724,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431707,-99) , 
0, 1.72796, 0, 0, 0.555214,-99) , 
4, 0.0196335, 1, 0, 0.724181,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.827015,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.257461,-99) , 
2, 3.80767, 0, 0, 0.337679,-99) , 
4, 0.101202, 1, 0, 0.567589,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.554422);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0457539, 1, 1, 0.824335,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464372,-99) , 
4, 1.41538, 1, 0, 0.771537,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.317394,-99) , 
0, 0.915394, 0, 0, 0.634105,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.448443);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 5.27833, 0, 1, 0.865249,-99) , 
NN(
NN(
0, 
0, 
-1, 0.718316, 0, 1, 0.689466,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55042,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.295351,-99) , 
0, 1.62292, 0, 0, 0.364242,-99) , 
5, 0.540268, 0, 0, 0.477245,-99) , 
0, 3.40197, 0, 0, 0.553853,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.501742);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.601587, 1, 1, 0.973159,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.665673,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.349677,-99) , 
4, 0.0620616, 1, 0, 0.50706,-99) , 
0, 3.40203, 0, 0, 0.58932,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.172698,-99) , 
4, 1.92084, 1, 0, 0.522826,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.420913);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.7443, 0, 1, 0.690858,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.672694,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.260733,-99) , 
2, 3.17521, 0, 0, 0.382436,-99) , 
5, 0.233909, 0, 0, 0.605104,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.445203);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 1.58387, 0, 1, 0.805198,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.622904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.347837,-99) , 
5, 0.724171, 0, 0, 0.413749,-99) , 
2, 6.30325, 0, 0, 0.466957,-99) , 
0, 4.23075, 0, 0, 0.534278,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.320013);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 4.68557, 0, 1, 0.913674,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576817,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4167,-99) , 
4, 0.100581, 1, 0, 0.521422,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.333519,-99) , 
0, 0.875152, 0, 0, 0.457915,-99) , 
0, 3.4019, 0, 0, 0.526866,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.322574);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.64387, 0, 1, 0.885506,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.717493,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483131,-99) , 
0, 3.31971, 0, 0, 0.515303,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.255839,-99) , 
4, 0.202799, 1, 0, 0.431988,-99) , 
2, 4.75838, 0, 0, 0.509551,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.311218);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.540406, 1, 1, 0.882247,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.660585,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.355064,-99) , 
5, 0.920777, 1, 0, 0.613734,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557565,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414974,-99) , 
0, 1.41887, 0, 0, 0.471123,-99) , 
5, 0.387115, 0, 0, 0.550925,-99) , 
0, 4.56895, 0, 0, 0.588457,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.335628);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 6.58386, 1, 1, 0.908161,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.611982,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.17333,-99) , 
0, 3.79594, 1, 0, 0.56491,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.369084,-99) , 
0, 0.861881, 0, 0, 0.50237,-99) , 
0, 4.23076, 0, 0, 0.543881,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.363493);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.40203, 0, 1, 0.65029,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.185728,-99) , 
4, 1.92226, 1, 0, 0.582715,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.203438);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.911669,-99) , 
NN(
NN(
0, 
0, 
-1, 0.0424583, 1, 1, 0.560206,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.330105,-99) , 
4, 1.31301, 1, 0, 0.525939,-99) , 
0, 5.38255, 0, 0, 0.55333,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.207066);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.885595,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.76066,-99) , 
NN(
0, 
0, 
-1, 0.901925, 0, -1, 0.437194,-99) , 
1, 249.859, 0, 0, 0.462072,-99) , 
0, 4.64517, 0, 0, 0.495195,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.263232);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.98978,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587143,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420404,-99) , 
5, 0.141958, 0, 0, 0.563073,-99) , 
0, 4.57036, 0, 0, 0.591845,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.275184,-99) , 
4, 1.31421, 1, 0, 0.548175,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.298231);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0.632273, 0, 1, 0.62082,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507988,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.244849,-99) , 
2, 0.48868, 0, 0, 0.387201,-99) , 
2, 1.26238, 0, 0, 0.524988,-99) , 
2, 13.058, 0, 0, 0.554787,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.401109);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.872197,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.724813,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.377405,-99) , 
4, 0.0229615, 1, 0, 0.495646,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608247,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.274471,-99) , 
3, 289.73, 0, 0, 0.351302,-99) , 
4, 0.101238, 1, 0, 0.430589,-99) , 
0, 4.64517, 0, 0, 0.463256,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.36521);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 5.90273, 0, 1, 0.699034,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400244,-99) , 
4, 0.0489466, 1, 0, 0.570053,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.702763,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.297531,-99) , 
3, 283.246, 0, 0, 0.389861,-99) , 
4, 0.101277, 1, 0, 0.497291,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.182926);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.46751, 1, 1, 0.619541,-99) , 
NN(
0, 
0, 
-1, 4.30697, 1, -1, 0.453971,-99) , 
0, 1.72798, 0, 0, 0.502374,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.263812,-99) , 
5, 0.111628, 0, 0, 0.469933,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.157471);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.808599,-99) , 
NN(
NN(
0, 
0, 
-1, 280.582, 0, 1, 0.538899,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407548,-99) , 
0, 0.857769, 0, 0, 0.49615,-99) , 
0, 4.18244, 0, 0, 0.523105,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.325209);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.888543,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.765487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422829,-99) , 
2, 4.55882, 1, 0, 0.595815,-99) , 
NN(
0, 
0, 
-1, 0.489507, 0, -1, 0.370127,-99) , 
2, 2.52389, 0, 0, 0.442039,-99) , 
2, 13.0592, 0, 0, 0.467048,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.204272);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.847057,-99) , 
NN(
NN(
0, 
0, 
-1, 0.479156, 0, 1, 0.565139,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546217,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.165977,-99) , 
5, 0.754892, 1, 0, 0.344131,-99) , 
0, 2.94773, 1, 0, 0.539184,-99) , 
0, 4.49406, 0, 0, 0.562153,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.204834);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 1.0203, 0, 1, 0.562006,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.352208,-99) , 
4, 0.80822, 1, 0, 0.528072,-99) , 
0, 4.52662, 0, 0, 0.556031,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.307084);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.745786,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.612422,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.371291,-99) , 
2, 2.29904, 0, 0, 0.447661,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.190607,-99) , 
2, 23.7884, 1, 0, 0.423906,-99) , 
0, 4.56897, 0, 0, 0.448926,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.279611);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.816045, 1, 1, 0.709039,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.800951,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44348,-99) , 
0, 1.46522, 0, 0, 0.479567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.199179,-99) , 
0, 1.80025, 1, 0, 0.431733,-99) , 
0, 2.11206, 0, 0, 0.485763,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.23324);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.917852,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.678026,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427983,-99) , 
5, 0.127026, 0, 0, 0.609312,-99) , 
NN(
0, 
0, 
-1, 3.35078, 1, -1, 0.460293,-99) , 
5, 0.448426, 1, 0, 0.536635,-99) , 
0, 4.18198, 0, 0, 0.559005,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.28082);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.31457, 0, 1, 0.693637,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51929,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.353174,-99) , 
5, 0.097937, 0, 0, 0.480485,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.290032,-99) , 
5, 0.297173, 1, 0, 0.445605,-99) , 
5, 0.356488, 0, 0, 0.571215,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.214883);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.787741,-99) , 
NN(
NN(
0, 
0, 
-1, 5.61021, 0, 1, 0.561005,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513342,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.26972,-99) , 
4, 0.198835, 1, 0, 0.376436,-99) , 
4, 0.101051, 1, 0, 0.493986,-99) , 
3, 312.684, 0, 0, 0.520237,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.320733);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.770779,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457432,-99) , 
5, 0.203502, 0, 0, 0.669443,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582987,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397677,-99) , 
5, 0.632201, 0, 0, 0.455808,-99) , 
2, 1.74063, 0, 0, 0.543346,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.184633,-99) , 
2, 26.9529, 1, 0, 0.507931,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.254237);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.656294,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463822,-99) , 
2, 2.44061, 0, 0, 0.51314,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.668191,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.178012,-99) , 
0, 4.63101, 0, 0, 0.335406,-99) , 
0, 3.36399, 1, 0, 0.479173,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.195118,-99) , 
2, 25.1923, 1, 0, 0.453157,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.36112);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.715394,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.72196,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.597452,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.244377,-99) , 
3, 3.73832, 0, 0, 0.448111,-99) , 
3, 55.89, 0, 0, 0.471498,-99) , 
3, 280.579, 0, 0, 0.491734,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.380411);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.101311, 1, 1, 0.629587,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.627752,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424485,-99) , 
4, 0.101202, 1, 0, 0.542988,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541504,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.16569,-99) , 
0, 1.69641, 0, 0, 0.222343,-99) , 
5, 0.335713, 1, 0, 0.375721,-99) , 
5, 0.571, 0, 0, 0.447625,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.162814);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.684174,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.733924,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462966,-99) , 
0, 1.67921, 0, 0, 0.501451,-99) , 
NN(
0, 
0, 
-1, 2.13623, 1, -1, 0.42818,-99) , 
5, 0.325889, 0, 0, 0.470756,-99) , 
0, 3.31449, 0, 0, 0.494312,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.169815);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 12.849, 0, 1, 0.729233,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.791874,-99) , 
NN(
0, 
0, 
-1, 0.490361, 0, -1, 0.451299,-99) , 
2, 3.7915, 0, 0, 0.475067,-99) , 
2, 6.53042, 0, 0, 0.503705,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.497474);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.855186,-99) , 
NN(
NN(
0, 
0, 
-1, 1.31457, 0, 1, 0.686164,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.69672,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.250312,-99) , 
3, 3.79399, 0, 0, 0.429805,-99) , 
3, 11.2808, 0, 0, 0.496239,-99) , 
3, 289.728, 0, 0, 0.529117,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.228036);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.687341,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493189,-99) , 
2, 0.633199, 0, 0, 0.63731,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.312226,-99) , 
2, 19.5883, 1, 0, 0.603013,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449355,-99) , 
0, 0.901358, 0, 0, 0.548591,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.190204);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.781907,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.691724,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499462,-99) , 
0, 1.59804, 0, 0, 0.530727,-99) , 
0, 2.5029, 0, 0, 0.565159,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578302,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496321,-99) , 
5, 0.0933615, 1, 0, 0.541762,-99) , 
NN(
0, 
0, 
-1, 3.21986, 1, -1, 0.309297,-99) , 
5, 0.139958, 1, 0, 0.396386,-99) , 
5, 0.264505, 0, 0, 0.497755,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.235838);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.877136,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.611543,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.322281,-99) , 
2, 4.20986, 1, 0, 0.576777,-99) , 
2, 6.52904, 0, 0, 0.607953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451329,-99) , 
0, 0.91042, 0, 0, 0.559059,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.245735);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.76481, 1, 1, 0.668416,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485342,-99) , 
0, 0.829508, 0, 0, 0.591462,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.644052,-99) , 
NN(
0, 
0, 
-1, 0.448916, 0, -1, 0.291107,-99) , 
4, 0.101277, 1, 0, 0.421687,-99) , 
0, 2.5355, 1, 0, 0.556578,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.159682);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.667621,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.735126,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478277,-99) , 
4, 0.00895339, 1, 0, 0.507122,-99) , 
4, 0.137057, 0, 0, 0.543854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378297,-99) , 
4, 1.41539, 1, 0, 0.524668,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.239886);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.325818, 0, 1, 0.597646,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.629502,-99) , 
NN(
0, 
0, 
-1, 3.30106, 1, -1, 0.292597,-99) , 
0, 4.3113, 0, 0, 0.38798,-99) , 
0, 2.57308, 1, 0, 0.549717,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.209493);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.592,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624287,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446743,-99) , 
5, 0.356433, 1, 0, 0.51037,-99) , 
0, 0.920814, 1, 0, 0.547852,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571855,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51785,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.182351,-99) , 
5, 0.326041, 0, 0, 0.299726,-99) , 
0, 3.54543, 0, 0, 0.405969,-99) , 
0, 2.12815, 1, 0, 0.512006,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.159594);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.57308, 0, 1, 0.565433,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404861,-99) , 
5, 0.111514, 0, 0, 0.541662,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.364813,-99) , 
4, 1.4153, 1, 0, 0.516509,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.274988);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.656249,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468772,-99) , 
5, 0.742896, 0, 0, 0.541074,-99) , 
0, 2.15906, 0, 0, 0.587701,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564727,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435481,-99) , 
5, 0.138721, 1, 0, 0.488122,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.215326,-99) , 
5, 0.30012, 1, 0, 0.388013,-99) , 
5, 0.387142, 0, 0, 0.48474,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.203584);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.486859, 1, 1, 0.680092,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534944,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.363119,-99) , 
0, 1.34258, 1, 0, 0.496063,-99) , 
0, 1.74424, 0, 0, 0.53367,-99) , 
NN(
0, 
0, 
-1, 0.940692, 0, -1, 0.31218,-99) , 
5, 0.846765, 1, 0, 0.496809,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.154891);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.745441,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508838,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.381456,-99) , 
5, 0.203537, 0, 0, 0.475048,-99) , 
2, 2.73694, 0, 0, 0.510821,-99) , 
NN(
0, 
0, 
-1, 0.662902, 1, -1, 0.367278,-99) , 
2, 6.5299, 1, 0, 0.486428,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.170604);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.733299,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47734,-99) , 
5, 0.499998, 1, 0, 0.552719,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.333207,-99) , 
0, 1.68409, 1, 0, 0.445448,-99) , 
5, 0.325938, 0, 0, 0.505198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.361445,-99) , 
4, 0.809449, 1, 0, 0.483972,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.264923);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.20807, 0, 1, 0.632782,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331679,-99) , 
0, 4.12849, 1, 0, 0.597468,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591346,-99) , 
NN(
0, 
0, 
-1, 0.156739, 0, -1, 0.378411,-99) , 
0, 2.95664, 0, 0, 0.406934,-99) , 
5, 0.325823, 0, 0, 0.523827,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.268103);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.614747,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420985,-99) , 
4, 0.505978, 1, 0, 0.573545,-99) , 
NN(
0, 
0, 
-1, 1.99617, 0, -1, 0.303217,-99) , 
2, 10.5547, 1, 0, 0.521439,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.35785,-99) , 
0, 0.90281, 0, 0, 0.461414,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.180325);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.91635, 0, 1, 0.569352,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.305614,-99) , 
4, 1.92225, 1, 0, 0.52749,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.147663);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.73451,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526739,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.38923,-99) , 
0, 1.7443, 1, 0, 0.488627,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.322686,-99) , 
5, 0.111603, 0, 0, 0.471404,-99) , 
1, 272.482, 0, 0, 0.486857,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.233067);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.509687, 1, 1, 0.702811,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.813799,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492746,-99) , 
5, 0.631665, 0, 0, 0.565713,-99) , 
NN(
0, 
0, 
-1, 0.724178, 1, -1, 0.381877,-99) , 
2, 1.56516, 0, 0, 0.44953,-99) , 
2, 5.39118, 0, 0, 0.478719,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.296527);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.779878,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.633707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.362007,-99) , 
2, 4.40717, 1, 0, 0.59395,-99) , 
NN(
0, 
0, 
-1, 0.475384, 0, -1, 0.377191,-99) , 
2, 1.05325, 0, 0, 0.498544,-99) , 
2, 6.5299, 0, 0, 0.526196,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.233213);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.799883,-99) , 
NN(
NN(
0, 
0, 
-1, 11.0559, 0, 1, 0.581397,-99) , 
NN(
0, 
0, 
-1, 2.44158, 1, -1, 0.3789,-99) , 
5, 0.203222, 0, 0, 0.520151,-99) , 
3, 283.241, 0, 0, 0.54878,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.269095);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.744513,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557344,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.376476,-99) , 
3, 10.9836, 0, 0, 0.431155,-99) , 
3, 280.581, 0, 0, 0.456934,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.33562,-99) , 
0, 0.908388, 0, 0, 0.416856,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.231482);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.748743,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558596,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.273586,-99) , 
2, 10.7806, 1, 0, 0.527013,-99) , 
0, 2.51328, 0, 0, 0.557461,-99) , 
NN(
0, 
0, 
-1, 0.902031, 0, -1, 0.349671,-99) , 
5, 0.724122, 1, 0, 0.503114,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.230244);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.509779, 1, 1, 0.610492,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.640203,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.344494,-99) , 
5, 0.897916, 0, 0, 0.468597,-99) , 
5, 0.774387, 1, 0, 0.550701,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443832,-99) , 
4, 0.0997542, 1, 0, 0.500415,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.370084,-99) , 
0, 1.31904, 0, 0, 0.42129,-99) , 
5, 0.41763, 0, 0, 0.478241,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.188315);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.0895326, 1, 1, 0.653964,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.643975,-99) , 
NN(
0, 
0, 
-1, 29.7389, 1, -1, 0.427025,-99) , 
3, 289.728, 0, 0, 0.446961,-99) , 
5, 0.172583, 1, 0, 0.484659,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.217963);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.787597,-99) , 
NN(
NN(
0, 
0, 
-1, 0.356413, 0, 1, 0.772986,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570747,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460095,-99) , 
0, 1.70653, 0, 0, 0.486428,-99) , 
2, 2.4383, 0, 0, 0.538248,-99) , 
2, 6.29916, 0, 0, 0.562268,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.207249);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 280.579, 0, 1, 0.576388,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587475,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.351776,-99) , 
0, 2.46601, 1, 0, 0.525142,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.185027,-99) , 
5, 0.691689, 0, 0, 0.457162,-99) , 
5, 0.632307, 1, 0, 0.532111,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.108031);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.809196,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471794,-99) , 
4, 0.123374, 1, 0, 0.657693,-99) , 
NN(
0, 
0, 
-1, 1.88588, 0, 1, 0.517504,-99) , 
0, 2.5461, 0, 0, 0.534307,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.342669,-99) , 
4, 1.91601, 1, 0, 0.508012,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.193976);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.877989,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.639616,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465497,-99) , 
0, 1.50566, 0, 0, 0.492854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.256518,-99) , 
0, 2.14099, 1, 0, 0.478249,-99) , 
0, 2.53503, 0, 0, 0.519961,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.220129);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 5.90436, 0, 1, 0.662353,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527124,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.347373,-99) , 
4, 0.0490943, 0, 0, 0.462505,-99) , 
4, 0.0196596, 1, 0, 0.508196,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546556,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.316944,-99) , 
3, 623.367, 0, 0, 0.370817,-99) , 
4, 0.202281, 1, 0, 0.471655,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.144967);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.770609,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.695172,-99) , 
NN(
0, 
0, 
-1, 1.62515, 1, -1, 0.460907,-99) , 
2, 4.98299, 0, 0, 0.480567,-99) , 
0, 2.98761, 0, 0, 0.506845,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.175054);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.64454,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.684255,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476251,-99) , 
0, 1.01615, 0, 0, 0.532212,-99) , 
NN(
0, 
0, 
-1, 10.7818, 1, -1, 0.395717,-99) , 
0, 1.34258, 1, 0, 0.480432,-99) , 
0, 3.4019, 0, 0, 0.494771,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.221942);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.0895695, 1, 1, 0.652464,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.721815,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.606359,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415163,-99) , 
5, 0.786364, 0, 0, 0.44897,-99) , 
3, 312.683, 0, 0, 0.471926,-99) , 
5, 0.172668, 1, 0, 0.503962,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.173314);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.448409, 1, 1, 0.725918,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57972,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474819,-99) , 
5, 0.181295, 0, 0, 0.550431,-99) , 
NN(
0, 
0, 
-1, 0.798483, 0, -1, 0.424161,-99) , 
5, 0.63206, 1, 0, 0.507968,-99) , 
0, 2.5355, 0, 0, 0.532156,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.251437);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.666495,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479218,-99) , 
4, 0.303384, 1, 0, 0.628612,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.272213,-99) , 
5, 0.946617, 1, 0, 0.584541,-99) , 
NN(
NN(
0, 
0, 
-1, 3.81081, 0, 1, 0.550367,-99) , 
NN(
0, 
0, 
-1, 0.349, 0, -1, 0.270061,-99) , 
5, 0.294184, 1, 0, 0.4675,-99) , 
5, 0.448409, 0, 0, 0.518927,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.179388);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.760413,-99) , 
NN(
NN(
0, 
0, 
-1, 2.03234, 0, 1, 0.548729,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535641,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.267182,-99) , 
0, 2.8673, 0, 0, 0.374235,-99) , 
0, 1.74421, 1, 0, 0.504385,-99) , 
2, 6.30039, 0, 0, 0.522683,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.208);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.703586,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.695902,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.609283,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416582,-99) , 
3, 20.0934, 0, 0, 0.446286,-99) , 
3, 564.482, 0, 0, 0.464261,-99) , 
5, 0.908061, 0, 0, 0.480399,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.182242);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.295406, 1, 1, 0.688503,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509639,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.314945,-99) , 
2, 0.435115, 0, 0, 0.460188,-99) , 
2, 3.36743, 0, 0, 0.497826,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.206948,-99) , 
2, 26.1168, 1, 0, 0.479314,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.16667);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.325895, 0, 1, 0.71574,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569192,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456891,-99) , 
2, 2.09176, 0, 0, 0.487464,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.261116,-99) , 
2, 10.7859, 1, 0, 0.470999,-99) , 
0, 2.11179, 0, 0, 0.501046,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.182978);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.728398,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.677746,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492226,-99) , 
5, 0.437517, 1, 0, 0.580747,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522259,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406215,-99) , 
0, 1.18308, 0, 0, 0.443262,-99) , 
0, 1.74481, 0, 0, 0.470257,-99) , 
5, 0.908063, 0, 0, 0.497108,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.204134);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.758043,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.723179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447738,-99) , 
5, 0.513096, 1, 0, 0.537121,-99) , 
NN(
0, 
0, 
-1, 0.23174, 1, -1, 0.437973,-99) , 
5, 0.346516, 0, 0, 0.484579,-99) , 
5, 0.816122, 0, 0, 0.511471,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.222773);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.76081,-99) , 
NN(
NN(
0, 
0, 
-1, 5.6301, 0, 1, 0.6044,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56895,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.377684,-99) , 
5, 0.540439, 1, 0, 0.488738,-99) , 
4, 0.101266, 1, 0, 0.552085,-99) , 
2, 6.52904, 0, 0, 0.566347,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.176841);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.723341,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5928,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497112,-99) , 
5, 0.479814, 0, 0, 0.534527,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.605095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.35091,-99) , 
3, 11.2598, 0, 0, 0.415082,-99) , 
0, 1.31898, 1, 0, 0.48641,-99) , 
3, 289.728, 0, 0, 0.50145,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.169028);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574189,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4547,-99) , 
5, 0.365285, 0, 0, 0.516022,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.266841,-99) , 
5, 0.938587, 1, 0, 0.497771,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.235513,-99) , 
2, 25.1923, 1, 0, 0.482832,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.201238);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.722518,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437421,-99) , 
3, 19.5303, 1, 0, 0.57071,-99) , 
0, 2.15864, 0, 0, 0.587547,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566574,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.361077,-99) , 
4, 1.5799, 0, 0, 0.493793,-99) , 
4, 0.302949, 1, 0, 0.570012,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.131964);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.692834,-99) , 
NN(
0, 
0, 
-1, 2.09865, 1, -1, 0.447139,-99) , 
0, 2.48343, 0, 0, 0.469503,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.237982);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.743204,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450039,-99) , 
1, 1.52154, 0, 0, 0.587505,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.316381,-99) , 
3, 54.6566, 1, 0, 0.560181,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539993,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.369694,-99) , 
5, 0.509562, 1, 0, 0.464447,-99) , 
4, 0.101298, 1, 0, 0.518677,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.153223);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.72516,-99) , 
NN(
NN(
0, 
0, 
-1, 11.7776, 0, 1, 0.605969,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.283538,-99) , 
3, 31.9509, 1, 0, 0.486085,-99) , 
5, 0.479043, 0, 0, 0.529532,-99) , 
3, 312.685, 0, 0, 0.544742,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.176975);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.101385, 0, 1, 0.605053,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568295,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.315704,-99) , 
5, 0.572914, 0, 0, 0.474516,-99) , 
5, 0.448327, 1, 0, 0.541288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446832,-99) , 
0, 0.90281, 0, 0, 0.505957,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.193668);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.886548,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.749925,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541516,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.374324,-99) , 
0, 1.72983, 1, 0, 0.510702,-99) , 
2, 3.06318, 0, 0, 0.534723,-99) , 
2, 5.27781, 0, 0, 0.556554,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.19924);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.781699,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537936,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389675,-99) , 
2, 0.707848, 0, 0, 0.48988,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.239952,-99) , 
2, 3.65181, 1, 0, 0.461498,-99) , 
2, 5.39154, 0, 0, 0.484759,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.151748);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.696522,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485637,-99) , 
5, 0.519454, 0, 0, 0.506995,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.355013,-99) , 
4, 0.80822, 1, 0, 0.484312,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507889,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.284168,-99) , 
4, 0.101313, 1, 0, 0.409594,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.254148,-99) , 
5, 0.691914, 0, 0, 0.375123,-99) , 
5, 0.632264, 1, 0, 0.45012,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.201478);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.732468,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425502,-99) , 
0, 1.32979, 1, 0, 0.506449,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524348,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.292017,-99) , 
5, 0.902152, 0, 0, 0.371408,-99) , 
5, 0.72405, 1, 0, 0.468321,-99) , 
2, 6.29901, 0, 0, 0.486584,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.218141);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.896015,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460003,-99) , 
4, 0.020119, 1, 0, 0.675008,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.674507,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463839,-99) , 
5, 0.78567, 0, 0, 0.491423,-99) , 
4, 0.0327471, 1, 0, 0.531852,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.285767,-99) , 
4, 1.01104, 1, 0, 0.497086,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.353018);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.825967,-99) , 
NN(
NN(
0, 
0, 
-1, 0.387111, 1, 1, 0.739054,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.765212,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.382109,-99) , 
1, 2.65277, 0, 0, 0.441032,-99) , 
3, 11.2808, 0, 0, 0.492491,-99) , 
3, 289.728, 0, 0, 0.516186,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.201827);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.804084,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.691566,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475531,-99) , 
5, 0.506817, 1, 0, 0.617507,-99) , 
5, 0.724261, 0, 0, 0.660185,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551302,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414623,-99) , 
0, 0.923212, 1, 0, 0.509804,-99) , 
0, 1.31904, 0, 0, 0.560955,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.184512);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.570913, 0, 1, 0.557953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.321861,-99) , 
2, 9.79908, 1, 0, 0.537479,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.642755,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.278048,-99) , 
3, 837.742, 0, 0, 0.387085,-99) , 
4, 0.303147, 1, 0, 0.511027,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.195133);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.8477, 1, 1, 0.682209,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585059,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439828,-99) , 
0, 1.0181, 0, 0, 0.500851,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.391057,-99) , 
5, 0.264811, 0, 0, 0.463955,-99) , 
0, 2.10249, 0, 0, 0.492352,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.154203);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.563822, 0, 1, 0.557413,-99) , 
NN(
0, 
0, 
-1, 0.728182, 0, -1, 0.379137,-99) , 
5, 0.662869, 1, 0, 0.503796,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.25016);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.621622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467115,-99) , 
4, 1.90462, 1, 0, 0.554488,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.866112,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.368326,-99) , 
5, 0.417755, 0, 0, 0.558421,-99) , 
NN(
0, 
0, 
-1, 2.95817, 1, -1, 0.386303,-99) , 
4, 0.0196304, 1, 0, 0.414421,-99) , 
4, 0.202293, 0, 0, 0.439777,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.205477);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 6.53026, 0, 1, 0.59333,-99) , 
NN(
0, 
0, 
-1, 0.92493, 1, -1, 0.350707,-99) , 
5, 0.87743, 1, 0, 0.558704,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.200134);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.616826,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444005,-99) , 
5, 0.157737, 0, 0, 0.577745,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630678,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423703,-99) , 
0, 2.07903, 0, 0, 0.451408,-99) , 
5, 0.398086, 1, 0, 0.500036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.355668,-99) , 
5, 0.111305, 0, 0, 0.479236,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.139047);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.797699,-99) , 
NN(
NN(
0, 
0, 
-1, 2.57306, 0, 1, 0.540506,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.358563,-99) , 
4, 0.705451, 1, 0, 0.51682,-99) , 
5, 0.908063, 0, 0, 0.534581,-99)    );
   return;
};

// Clean up
inline void ReadBDTh::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDTh::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}

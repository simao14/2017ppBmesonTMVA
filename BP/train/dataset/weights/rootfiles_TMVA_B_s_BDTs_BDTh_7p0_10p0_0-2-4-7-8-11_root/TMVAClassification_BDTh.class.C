// Class: ReadBDTh
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTh
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.22/01       [398849]
Creator        : tasheng
Date           : Sat Feb 25 00:07:33 2023
Host           : Linux GRENDEL01.MIT.EDU 3.10.0-957.21.3.el7.x86_64 #1 SMP Tue Jun 18 16:35:19 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/tasheng/bmva_nom/bmva_trk5/TMVA/BP/train
Training events: 36744
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "5.0%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "30" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
BaggedSampleFraction: "5.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "5.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 6
Btrk1Pt                       Btrk1Pt                       Btrk1Pt                       Btrk1Pt                                                         'F'    [0.500005543232,6.86356019974]
abs(Btrk1Dz1/Btrk1DzError1)   Trk1DCAz                      Trk1DCAz                      Trk1DCAz                                                        'F'    [0.000220876332605,5734.04785156]
abs(Btrk1Dxy1/Btrk1DxyError1) Trk1DCAxy                     Trk1DCAxy                     Trk1DCAxy                                                       'F'    [1.54770023073e-05,130.999252319]
BsvpvDistance/BsvpvDisErr     dls                           dls                           dls                                                             'F'    [2.00010490417,8607.85058594]
Balpha                        Balpha                        Balpha                        Balpha                                                          'F'    [1.95912252821e-05,3.13992762566]
Bchi2cl                       Bchi2cl                       Bchi2cl                       Bchi2cl                                                         'F'    [0.0500063411891,0.999989449978]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDThNode

#ifndef BDThNode__def
#define BDThNode__def

class BDThNode {

public:

   // constructor of an essentially "empty" node floating in space
   BDThNode ( BDThNode* left,BDThNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDThNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDThNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDThNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDThNode*   fLeft;     // pointer to the left daughter node
   BDThNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDThNode::~BDThNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDThNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] >= fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDThNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTh : public IClassifierReader {

 public:

   // constructor
   ReadBDTh( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDTh" ),
        fNvars( 6 )
   {
      // the training input variables
      const char* inputVars[] = { "Btrk1Pt", "abs(Btrk1Dz1/Btrk1DzError1)", "abs(Btrk1Dxy1/Btrk1DxyError1)", "BsvpvDistance/BsvpvDisErr", "Balpha", "Bchi2cl" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTh() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[6];
   double fVmax[6];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[6];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDThNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTh::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDThNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDThNode*)current->GetRight();
         else current=(BDThNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDTh::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(1.05144766259094);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.099462, 1, 1, 0.976279,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.896556,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.353248,-99) , 
0, 1.09968, 0, 0, 0.613811,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50204,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0810151,-99) , 
0, 1.62386, 0, 0, 0.125669,-99) , 
4, 0.101407, 1, 0, 0.251651,-99) , 
2, 3.01696, 0, 0, 0.499913,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.896487);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.02025, 0, 1, 0.972162,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.820945,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331909,-99) , 
3, 3.9543, 0, 0, 0.621608,-99) , 
3, 9.56577, 0, 0, 0.8451,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.956865,-99) , 
NN(
0, 
0, 
-1, 1.06632, 0, -1, 0.185935,-99) , 
2, 4.07228, 0, 0, 0.262756,-99) , 
4, 0.101192, 1, 0, 0.516783,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.690644);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.264553, 0, 1, 0.971153,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.786639,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407538,-99) , 
0, 0.903245, 0, 0, 0.609686,-99) , 
NN(
0, 
0, 
-1, 0.892452, 0, -1, 0.218754,-99) , 
4, 0.202946, 1, 0, 0.391397,-99) , 
2, 4.07177, 0, 0, 0.533046,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.610638);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.06852, 0, 1, 0.981534,-99) , 
NN(
NN(
0, 
0, 
-1, 0.202796, 1, 1, 0.72502,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534949,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.233216,-99) , 
0, 1.32116, 0, 0, 0.306597,-99) , 
2, 1.63574, 0, 0, 0.440022,-99) , 
2, 4.2258, 0, 0, 0.556311,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.487929);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.356563, 0, 1, 0.938181,-99) , 
NN(
NN(
0, 
0, 
-1, 2.04451, 0, 1, 0.623708,-99) , 
NN(
0, 
0, 
-1, 1.02718, 0, -1, 0.289809,-99) , 
4, 0.202303, 1, 0, 0.444902,-99) , 
2, 4.2258, 0, 0, 0.548401,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.40405);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.233978, 0, 1, 0.914083,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.752652,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497288,-99) , 
2, 1.85593, 0, 0, 0.566212,-99) , 
NN(
0, 
0, 
-1, 0.304021, 1, -1, 0.322467,-99) , 
0, 0.89255, 0, 0, 0.441823,-99) , 
2, 3.38413, 0, 0, 0.550844,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.441818);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.356461, 0, 1, 0.92854,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.642134,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.383024,-99) , 
5, 0.264468, 0, 0, 0.559788,-99) , 
NN(
0, 
0, 
-1, 0.40464, 1, -1, 0.314614,-99) , 
0, 0.701514, 0, 0, 0.478656,-99) , 
2, 3.63839, 0, 0, 0.570237,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.342208);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.325901, 0, 1, 0.935318,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.77127,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497858,-99) , 
4, 0.0493029, 1, 0, 0.567632,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525717,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.161576,-99) , 
1, 139.49, 0, 0, 0.322791,-99) , 
4, 0.506772, 1, 0, 0.491872,-99) , 
2, 4.22616, 0, 0, 0.565571,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.412427);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.76468, 0, 1, 0.903109,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.692078,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478759,-99) , 
5, 0.478823, 0, 0, 0.569411,-99) , 
4, 0.0326125, 1, 0, 0.656672,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.650691,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.321878,-99) , 
0, 0.892411, 0, 0, 0.500804,-99) , 
NN(
0, 
0, 
-1, 0.89314, 0, -1, 0.153066,-99) , 
3, 239.117, 0, 0, 0.346487,-99) , 
4, 0.505518, 1, 0, 0.565625,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.358512);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.25742, 0, 1, 0.953154,-99) , 
NN(
NN(
0, 
0, 
-1, 2.04458, 0, 1, 0.597275,-99) , 
NN(
0, 
0, 
-1, 199.869, 0, -1, 0.313822,-99) , 
4, 0.505347, 1, 0, 0.512664,-99) , 
2, 4.22592, 0, 0, 0.577048,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.297706);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.100285, 1, 1, 0.902722,-99) , 
NN(
NN(
0, 
0, 
-1, 0.447655, 0, 1, 0.684589,-99) , 
NN(
0, 
0, 
-1, 0.505608, 1, -1, 0.429929,-99) , 
2, 2.10185, 0, 0, 0.473703,-99) , 
2, 3.42963, 0, 0, 0.548893,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.20736);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.29971, 0, 1, 0.908069,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.796684,-99) , 
NN(
0, 
0, 
-1, 0.563266, 0, -1, 0.467338,-99) , 
0, 2.46224, 0, 0, 0.494306,-99) , 
2, 4.22592, 0, 0, 0.55037,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.286904);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.417842, 0, 1, 0.906678,-99) , 
NN(
NN(
0, 
0, 
-1, 0.784853, 0, 1, 0.618755,-99) , 
NN(
0, 
0, 
-1, 0.699943, 0, -1, 0.425038,-99) , 
2, 0.954187, 0, 0, 0.530053,-99) , 
2, 4.2258, 0, 0, 0.580118,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.342874);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.387144, 0, 1, 0.867961,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635889,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441294,-99) , 
0, 0.697939, 0, 0, 0.579739,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563295,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.266875,-99) , 
1, 348.706, 0, 0, 0.360108,-99) , 
4, 0.404768, 1, 0, 0.510719,-99) , 
2, 4.2258, 0, 0, 0.557571,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.191171);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.356482, 0, 1, 0.894464,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.662045,-99) , 
NN(
0, 
0, 
-1, 2.83013, 1, -1, 0.475254,-99) , 
0, 1.89919, 0, 0, 0.501123,-99) , 
2, 3.4295, 0, 0, 0.557961,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.208311);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.924029,-99) , 
NN(
NN(
0, 
0, 
-1, 3.8625, 0, 1, 0.647903,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51259,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.258707,-99) , 
4, 2.84587, 1, 0, 0.485086,-99) , 
4, 0.101307, 1, 0, 0.540121,-99) , 
2, 6.76825, 0, 0, 0.570835,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.239588);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.30017, 0, 1, 0.83246,-99) , 
NN(
NN(
0, 
0, 
-1, 2.17741, 0, 1, 0.579223,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558451,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.384043,-99) , 
0, 1.48126, 0, 0, 0.42745,-99) , 
5, 0.356375, 0, 0, 0.516411,-99) , 
2, 4.2258, 0, 0, 0.554047,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.191112);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.417842, 0, 1, 0.838438,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.717977,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466207,-99) , 
5, 0.325909, 0, 0, 0.610285,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506894,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396462,-99) , 
4, 0.304392, 1, 0, 0.460759,-99) , 
2, 2.04425, 0, 0, 0.489117,-99) , 
2, 4.22592, 0, 0, 0.527027,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.204008);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.992606,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.774844,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483622,-99) , 
2, 2.18122, 0, 0, 0.540788,-99) , 
NN(
0, 
0, 
-1, 0.201152, 0, -1, 0.377136,-99) , 
5, 0.172576, 0, 0, 0.502073,-99) , 
2, 8.45202, 0, 0, 0.526235,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.204622);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.795582,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.834051,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549323,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.387692,-99) , 
4, 0.708177, 1, 0, 0.510495,-99) , 
2, 6.54361, 0, 0, 0.53077,-99) , 
0, 2.3475, 0, 0, 0.554946,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.13133);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.852111,-99) , 
NN(
NN(
0, 
0, 
-1, 2.29866, 0, 1, 0.52763,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.242951,-99) , 
4, 2.82867, 1, 0, 0.503422,-99) , 
2, 8.4517, 0, 0, 0.524176,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.246737);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.883535,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.700034,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430761,-99) , 
1, 1.99735, 0, 0, 0.520719,-99) , 
1, 4.76384, 0, 0, 0.628016,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.67224,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480666,-99) , 
1, 576.46, 0, 0, 0.514124,-99) , 
NN(
0, 
0, 
-1, 0.601319, 0, -1, 0.37174,-99) , 
0, 0.892504, 0, 0, 0.448722,-99) , 
4, 0.101036, 1, 0, 0.509692,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.179052);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.94684,-99) , 
NN(
NN(
0, 
0, 
-1, 0.201722, 1, 1, 0.641087,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.646816,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480555,-99) , 
3, 434.047, 0, 0, 0.513737,-99) , 
5, 0.754691, 0, 0, 0.54048,-99) , 
2, 6.14635, 0, 0, 0.565504,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.1719);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.784241,-99) , 
NN(
NN(
0, 
0, 
-1, 1.02276, 0, 1, 0.674194,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.62722,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464878,-99) , 
2, 2.11104, 0, 0, 0.48977,-99) , 
2, 3.27205, 0, 0, 0.513338,-99) , 
0, 2.29866, 0, 0, 0.537954,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.177302);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 9.54556, 0, 1, 0.792706,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.595191,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4974,-99) , 
4, 0.586567, 1, 0, 0.551732,-99) , 
4, 0.100476, 1, 0, 0.630147,-99) , 
NN(
NN(
0, 
0, 
-1, 0.81608, 0, 1, 0.542074,-99) , 
NN(
0, 
0, 
-1, 0.5399, 0, -1, 0.302458,-99) , 
0, 0.577358, 0, 0, 0.504062,-99) , 
0, 1.29941, 0, 0, 0.544809,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.156624);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.448328, 0, 1, 0.733867,-99) , 
NN(
NN(
0, 
0, 
-1, 0.0195608, 1, 1, 0.543839,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552573,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.381837,-99) , 
3, 396.268, 0, 0, 0.460497,-99) , 
4, 0.302947, 1, 0, 0.513776,-99) , 
0, 2.14233, 0, 0, 0.536439,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.137251);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.718294,-99) , 
NN(
NN(
0, 
0, 
-1, 2.59014, 0, 1, 0.540737,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567383,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430176,-99) , 
3, 140.513, 0, 0, 0.460517,-99) , 
5, 0.356375, 0, 0, 0.5072,-99) , 
2, 4.22625, 0, 0, 0.52699,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.168522);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.879889,-99) , 
NN(
NN(
0, 
0, 
-1, 1.96157, 0, 1, 0.584759,-99) , 
NN(
0, 
0, 
-1, 0.111299, 0, -1, 0.447014,-99) , 
0, 1.08868, 0, 0, 0.50315,-99) , 
2, 6.76869, 0, 0, 0.524195,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0849622);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.676031,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.633198,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566911,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488896,-99) , 
5, 0.815982, 0, 0, 0.500074,-99) , 
2, 2.75792, 0, 0, 0.510369,-99) , 
2, 4.07177, 0, 0, 0.526538,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.148849);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.745696,-99) , 
NN(
NN(
0, 
0, 
-1, 0.386863, 0, 1, 0.637764,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554003,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468935,-99) , 
1, 364.506, 0, 0, 0.481466,-99) , 
2, 1.90797, 0, 0, 0.516003,-99) , 
2, 4.2258, 0, 0, 0.536245,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.152432);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.100563, 1, 1, 0.634512,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.67359,-99) , 
NN(
0, 
0, 
-1, 0.0994203, 0, -1, 0.472511,-99) , 
5, 0.816122, 0, 0, 0.505298,-99) , 
0, 1.32111, 0, 0, 0.543067,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.183373);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.705729,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572846,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433413,-99) , 
2, 0.663357, 0, 0, 0.525007,-99) , 
2, 3.42963, 0, 0, 0.54678,-99) , 
NN(
0, 
0, 
-1, 1.94488, 1, -1, 0.395972,-99) , 
5, 0.17259, 0, 0, 0.514026,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.10682);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.82232,-99) , 
NN(
NN(
0, 
0, 
-1, 2.97371, 0, 1, 0.533964,-99) , 
NN(
0, 
0, 
-1, 1.58587, 1, -1, 0.44892,-99) , 
5, 0.172578, 0, 0, 0.514954,-99) , 
2, 6.1467, 0, 0, 0.531609,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.203631);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.893278,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.718916,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.408621,-99) , 
1, 2.30399, 0, 0, 0.493373,-99) , 
1, 4.76384, 0, 0, 0.590178,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537971,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444865,-99) , 
0, 1.44345, 1, 0, 0.496653,-99) , 
NN(
0, 
0, 
-1, 0.601283, 0, -1, 0.432991,-99) , 
0, 0.892491, 0, 0, 0.468656,-99) , 
4, 0.101383, 1, 0, 0.509287,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0655172);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.719999,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.634991,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501774,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.405699,-99) , 
0, 0.566272, 0, 0, 0.490898,-99) , 
0, 2.5528, 0, 0, 0.500272,-99) , 
2, 6.14691, 0, 0, 0.513996,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.119444);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.387125, 0, 1, 0.723485,-99) , 
NN(
NN(
0, 
0, 
-1, 0.72419, 0, 1, 0.55301,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518282,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44459,-99) , 
0, 1.09388, 1, 0, 0.491069,-99) , 
2, 1.21684, 0, 0, 0.514338,-99) , 
2, 3.4295, 0, 0, 0.536611,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.172515);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.847408,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577147,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438675,-99) , 
2, 2.10438, 1, 0, 0.541341,-99) , 
4, 0.0196206, 1, 0, 0.583156,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565825,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452327,-99) , 
0, 1.62693, 1, 0, 0.52294,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397388,-99) , 
5, 0.540276, 0, 0, 0.449418,-99) , 
0, 0.892701, 0, 0, 0.490961,-99) , 
4, 0.202594, 1, 0, 0.537631,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.138214);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.788979,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555507,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468197,-99) , 
2, 1.18038, 0, 0, 0.507351,-99) , 
NN(
0, 
0, 
-1, 2.8668, 1, -1, 0.430516,-99) , 
4, 0.404381, 1, 0, 0.482685,-99) , 
2, 4.07222, 0, 0, 0.505288,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.144415);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.356806, 0, 1, 0.630804,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588733,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.410195,-99) , 
0, 0.583737, 0, 0, 0.540747,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419138,-99) , 
5, 0.387097, 0, 0, 0.46374,-99) , 
0, 0.870818, 1, 0, 0.502318,-99) , 
0, 2.14222, 0, 0, 0.517028,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.186461);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.35187, 0, 1, 0.764271,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573846,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.391777,-99) , 
5, 0.356436, 0, 0, 0.483104,-99) , 
4, 0.0294625, 1, 0, 0.570122,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603475,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.387919,-99) , 
4, 2.89363, 1, 0, 0.540147,-99) , 
NN(
0, 
0, 
-1, 1.05502, 0, -1, 0.448734,-99) , 
4, 2.55182, 0, 0, 0.472829,-99) , 
4, 0.101348, 1, 0, 0.505464,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0987489);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.666558,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572685,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495488,-99) , 
5, 0.540321, 1, 0, 0.544221,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524435,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449257,-99) , 
0, 0.692213, 1, 0, 0.48824,-99) , 
0, 0.996469, 0, 0, 0.513258,-99) , 
0, 2.69881, 0, 0, 0.522403,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0665225);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.707298,-99) , 
NN(
NN(
0, 
0, 
-1, 4.07228, 0, 1, 0.515727,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397103,-99) , 
4, 2.82866, 1, 0, 0.505675,-99) , 
0, 2.75806, 0, 0, 0.51673,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.14959);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.88049,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.604208,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4885,-99) , 
4, 0.189645, 0, 0, 0.530639,-99) , 
4, 0.0163016, 1, 0, 0.555227,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575049,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439961,-99) , 
0, 1.25495, 0, 0, 0.480315,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.317258,-99) , 
4, 2.87594, 1, 0, 0.446895,-99) , 
4, 0.504851, 1, 0, 0.525767,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.185812);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.862479,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.633475,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456111,-99) , 
1, 1.65778, 0, 0, 0.530692,-99) , 
1, 4.67157, 0, 0, 0.612897,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603262,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466073,-99) , 
2, 1.68793, 1, 0, 0.557641,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545048,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439913,-99) , 
4, 0.492576, 0, 0, 0.4915,-99) , 
5, 0.387097, 1, 0, 0.524111,-99) , 
4, 0.101119, 1, 0, 0.550869,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0979762);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.869509, 1, 1, 0.619808,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.615774,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515446,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397918,-99) , 
0, 0.552273, 0, 0, 0.504038,-99) , 
0, 2.11207, 0, 0, 0.516761,-99) , 
5, 0.816123, 0, 0, 0.534252,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.109676);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.654569,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59336,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46779,-99) , 
2, 4.07177, 0, 0, 0.477435,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.349063,-99) , 
5, 0.0806526, 0, 0, 0.467651,-99) , 
0, 2.31331, 0, 0, 0.483124,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.122177);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.609636,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.634066,-99) , 
NN(
0, 
0, 
-1, 3.4487, 1, -1, 0.448102,-99) , 
2, 5.0942, 0, 0, 0.458541,-99) , 
0, 2.3475, 0, 0, 0.470704,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0714438);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.677234,-99) , 
NN(
NN(
0, 
0, 
-1, 2.31331, 0, 1, 0.517024,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429621,-99) , 
2, 0.272968, 0, 0, 0.504456,-99) , 
2, 4.22616, 0, 0, 0.516876,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0902712);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.66268,-99) , 
NN(
NN(
0, 
0, 
-1, 0.100484, 1, 1, 0.553315,-99) , 
NN(
0, 
0, 
-1, 0.303043, 1, -1, 0.46974,-99) , 
0, 1.39382, 0, 0, 0.486636,-99) , 
0, 2.34768, 0, 0, 0.500542,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.126919);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0180118, 1, 1, 0.676397,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530163,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460755,-99) , 
0, 1.60985, 1, 0, 0.516366,-99) , 
4, 0.0327699, 1, 0, 0.541268,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549073,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.410351,-99) , 
4, 2.41435, 0, 0, 0.490088,-99) , 
NN(
0, 
0, 
-1, 2.71522, 1, -1, 0.393734,-99) , 
3, 279.608, 0, 0, 0.446007,-99) , 
4, 0.506523, 1, 0, 0.513851,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0551351);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630891,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608453,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499862,-99) , 
2, 4.2258, 0, 0, 0.50843,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399153,-99) , 
4, 2.82734, 1, 0, 0.498013,-99) , 
3, 1112.43, 0, 0, 0.509811,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.151579);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.757233,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563187,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4326,-99) , 
1, 1.72745, 0, 0, 0.494999,-99) , 
3, 9.56467, 0, 0, 0.577839,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.622817,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478537,-99) , 
4, 0.58874, 1, 0, 0.570498,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520532,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449289,-99) , 
0, 1.28491, 0, 0, 0.470647,-99) , 
5, 0.17259, 1, 0, 0.494572,-99) , 
4, 0.101058, 1, 0, 0.520462,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.125706);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.828487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490947,-99) , 
3, 9.545, 0, 0, 0.589076,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517843,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40029,-99) , 
0, 1.63657, 1, 0, 0.491904,-99) , 
4, 0.101242, 1, 0, 0.522235,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.361721,-99) , 
5, 0.080651, 0, 0, 0.510434,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0874738);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.665647,-99) , 
NN(
NN(
0, 
0, 
-1, 0.168734, 1, 1, 0.53343,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440378,-99) , 
5, 0.111296, 0, 0, 0.519961,-99) , 
0, 2.71627, 0, 0, 0.527225,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.128426);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.858065,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607257,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463641,-99) , 
5, 0.662881, 0, 0, 0.499214,-99) , 
1, 4.76384, 0, 0, 0.571848,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512017,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402781,-99) , 
1, 278.978, 1, 0, 0.489552,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402553,-99) , 
0, 1.82972, 1, 0, 0.474709,-99) , 
4, 0.100995, 1, 0, 0.504413,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.139118);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.622516,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.674882,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444325,-99) , 
3, 8.33481, 0, 0, 0.513105,-99) , 
NN(
0, 
0, 
-1, 0.479032, 1, -1, 0.449834,-99) , 
4, 0.101006, 1, 0, 0.469948,-99) , 
0, 2.14224, 0, 0, 0.485106,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.118073);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.663573,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585508,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492298,-99) , 
2, 0.954829, 0, 0, 0.542033,-99) , 
2, 4.22669, 0, 0, 0.552258,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564088,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472079,-99) , 
5, 0.417544, 1, 0, 0.52146,-99) , 
NN(
0, 
0, 
-1, 2.04261, 0, -1, 0.419398,-99) , 
4, 0.304527, 1, 0, 0.486919,-99) , 
0, 0.705281, 0, 0, 0.532462,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0608637);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.610744,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57362,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489003,-99) , 
4, 2.37241, 0, 0, 0.499678,-99) , 
0, 2.31334, 0, 0, 0.508081,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418727,-99) , 
4, 2.82866, 1, 0, 0.500748,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.113807);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0196329, 1, 1, 0.561897,-99) , 
NN(
0, 
0, 
-1, 554.909, 1, -1, 0.464086,-99) , 
4, 0.303896, 1, 0, 0.525022,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.384708,-99) , 
5, 0.0806541, 0, 0, 0.514901,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.111128);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.684699,-99) , 
NN(
NN(
0, 
0, 
-1, 0.203391, 1, 1, 0.541386,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60268,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456242,-99) , 
5, 0.877228, 0, 0, 0.472708,-99) , 
0, 1.29461, 0, 0, 0.490308,-99) , 
0, 2.55277, 0, 0, 0.500636,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.107242);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.738002,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559962,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457444,-99) , 
1, 1.07189, 0, 0, 0.519874,-99) , 
1, 4.74878, 0, 0, 0.566568,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527888,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476534,-99) , 
4, 0.630779, 0, 0, 0.49237,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396917,-99) , 
4, 2.83844, 1, 0, 0.480732,-99) , 
4, 0.101083, 1, 0, 0.508746,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0863964);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.707131,-99) , 
NN(
NN(
0, 
0, 
-1, 3.02223, 0, 1, 0.529755,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446735,-99) , 
0, 0.566307, 0, 0, 0.520666,-99) , 
0, 2.55282, 0, 0, 0.532147,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.127678);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.633652,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.646008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479909,-99) , 
4, 0.0392149, 1, 0, 0.5082,-99) , 
NN(
0, 
0, 
-1, 37.7731, 0, -1, 0.395121,-99) , 
4, 0.607778, 1, 0, 0.482343,-99) , 
3, 1112.43, 0, 0, 0.496908,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.155183);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.0294198, 1, 1, 0.56588,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584779,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453422,-99) , 
1, 555.123, 1, 0, 0.534021,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549979,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.33028,-99) , 
3, 19.8069, 0, 0, 0.415026,-99) , 
3, 278.294, 0, 0, 0.479488,-99) , 
4, 0.303882, 1, 0, 0.532439,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0846175);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587864,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553143,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481053,-99) , 
5, 0.724185, 0, 0, 0.496357,-99) , 
4, 1.76435, 0, 0, 0.506645,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552278,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.316395,-99) , 
4, 2.87858, 1, 0, 0.440752,-99) , 
4, 2.7348, 1, 0, 0.499288,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.118459);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.776265,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555246,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420504,-99) , 
4, 0.0684119, 1, 0, 0.512804,-99) , 
4, 0.0228873, 1, 0, 0.567155,-99) , 
NN(
NN(
0, 
0, 
-1, 0.696283, 1, 1, 0.527279,-99) , 
NN(
0, 
0, 
-1, 0.491877, 1, -1, 0.428493,-99) , 
5, 0.693545, 1, 0, 0.503844,-99) , 
4, 0.101307, 1, 0, 0.523242,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0794954);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568712,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.745832,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483216,-99) , 
1, 4.76763, 0, 0, 0.538941,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501646,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456885,-99) , 
5, 0.356455, 1, 0, 0.476446,-99) , 
4, 0.0911983, 1, 0, 0.49498,-99) , 
4, 2.82532, 0, 0, 0.501233,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0747994);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0912213, 1, 1, 0.550445,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503749,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441701,-99) , 
5, 0.203224, 0, 0, 0.486125,-99) , 
0, 1.32111, 0, 0, 0.505438,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373898,-99) , 
4, 2.82763, 1, 0, 0.493676,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.096608);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.697321,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548146,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443876,-99) , 
4, 0.0393608, 0, 0, 0.509322,-99) , 
1, 4.67157, 0, 0, 0.549226,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54463,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502376,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42788,-99) , 
4, 0.49259, 1, 0, 0.471919,-99) , 
5, 0.111287, 1, 0, 0.481587,-99) , 
4, 0.10124, 1, 0, 0.502709,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.128028);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.479005, 0, 1, 0.648031,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556591,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481559,-99) , 
4, 0.296138, 0, 0, 0.49612,-99) , 
4, 0.0394813, 1, 0, 0.52032,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600602,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.411195,-99) , 
1, 432.559, 1, 0, 0.505182,-99) , 
NN(
0, 
0, 
-1, 0.325575, 1, -1, 0.361313,-99) , 
3, 279.608, 0, 0, 0.441747,-99) , 
4, 0.60796, 1, 0, 0.499344,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.106348);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647508,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568997,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483852,-99) , 
2, 0.586896, 1, 0, 0.511437,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505109,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.32361,-99) , 
2, 0.935662, 0, 0, 0.425378,-99) , 
4, 0.710224, 1, 0, 0.489327,-99) , 
2, 3.63816, 0, 0, 0.50111,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.075196);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565983,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527749,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439482,-99) , 
5, 0.0984325, 0, 0, 0.499067,-99) , 
NN(
0, 
0, 
-1, 0.35942, 0, -1, 0.465848,-99) , 
5, 0.26452, 1, 0, 0.476829,-99) , 
0, 2.55277, 0, 0, 0.482607,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.102222);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.649486,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544595,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.398653,-99) , 
0, 1.08835, 1, 0, 0.488417,-99) , 
3, 8.02721, 0, 0, 0.53768,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526294,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477724,-99) , 
5, 0.306969, 0, 0, 0.505833,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413381,-99) , 
5, 0.846766, 1, 0, 0.495045,-99) , 
4, 0.101109, 1, 0, 0.508614,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.089564);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0913742, 1, 1, 0.594377,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512649,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.363917,-99) , 
5, 0.197311, 0, 0, 0.499138,-99) , 
5, 0.141939, 1, 0, 0.518625,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.356995,-99) , 
4, 2.83009, 1, 0, 0.508789,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.126602);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 10.3155, 0, 1, 0.594578,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429828,-99) , 
5, 0.141974, 0, 0, 0.558641,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517863,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.39357,-99) , 
0, 1.59977, 1, 0, 0.491528,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511414,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.320247,-99) , 
3, 279.608, 0, 0, 0.434228,-99) , 
4, 0.688191, 1, 0, 0.471839,-99) , 
4, 0.10116, 1, 0, 0.498487,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.125249);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.496393, 0, 1, 0.605211,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.194702,-99) , 
4, 0.707925, 1, 0, 0.479723,-99) , 
1, 5.06594, 0, 0, 0.510799,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546548,-99) , 
NN(
0, 
0, 
-1, 1.08823, 0, -1, 0.370057,-99) , 
5, 0.356822, 1, 0, 0.437835,-99) , 
1, 157.15, 1, 0, 0.495579,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0952142);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.609672,-99) , 
NN(
NN(
0, 
0, 
-1, 0.479221, 0, 1, 0.550638,-99) , 
NN(
0, 
0, 
-1, 1.30602, 1, -1, 0.457803,-99) , 
2, 2.18072, 0, 0, 0.473061,-99) , 
2, 4.22616, 0, 0, 0.481081,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.12079);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.605864,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416767,-99) , 
0, 0.770686, 0, 0, 0.537739,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563624,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462217,-99) , 
2, 4.07486, 0, 0, 0.472055,-99) , 
0, 0.896524, 1, 0, 0.489098,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522942,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505189,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.338876,-99) , 
2, 1.25357, 0, 0, 0.407331,-99) , 
0, 0.636419, 0, 0, 0.445581,-99) , 
0, 0.701484, 0, 0, 0.476716,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.132141);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.201653, 1, 1, 0.568506,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58115,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448247,-99) , 
5, 0.152927, 1, 0, 0.493226,-99) , 
5, 0.448393, 0, 0, 0.526865,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.583993,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4583,-99) , 
5, 0.178459, 0, 0, 0.51982,-99) , 
NN(
0, 
0, 
-1, 0.639042, 1, -1, 0.430728,-99) , 
5, 0.35643, 1, 0, 0.470087,-99) , 
0, 1.11583, 0, 0, 0.490911,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.174832);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 5.05971, 0, 1, 0.631561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419121,-99) , 
1, 157.153, 1, 0, 0.580993,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584796,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417201,-99) , 
0, 0.696486, 0, 0, 0.537985,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521021,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423031,-99) , 
0, 1.91046, 0, 0, 0.436254,-99) , 
5, 0.168616, 1, 0, 0.467509,-99) , 
5, 0.662855, 0, 0, 0.498828,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.123316);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.632957,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590427,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444435,-99) , 
4, 0.201761, 1, 0, 0.511277,-99) , 
0, 1.32152, 0, 0, 0.547507,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.616463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477075,-99) , 
5, 0.137013, 1, 0, 0.510345,-99) , 
NN(
0, 
0, 
-1, 0.0457702, 1, -1, 0.438567,-99) , 
4, 0.202284, 0, 0, 0.473848,-99) , 
5, 0.724188, 0, 0, 0.489798,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.109714);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598777,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575002,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444067,-99) , 
3, 279.608, 0, 0, 0.517314,-99) , 
5, 0.724221, 0, 0, 0.54096,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.666633,-99) , 
NN(
0, 
0, 
-1, 0.87959, 0, -1, 0.469531,-99) , 
4, 0.026116, 1, 0, 0.489685,-99) , 
4, 0.404148, 0, 0, 0.506338,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.130593);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0294985, 1, 1, 0.578857,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538802,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420409,-99) , 
5, 0.174632, 0, 0, 0.499893,-99) , 
4, 0.303953, 1, 0, 0.551556,-99) , 
NN(
NN(
0, 
0, 
-1, 0.940313, 0, 1, 0.539718,-99) , 
NN(
0, 
0, 
-1, 1.09968, 0, -1, 0.428947,-99) , 
5, 0.794403, 0, 0, 0.485276,-99) , 
5, 0.601613, 1, 0, 0.530039,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0798747);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.633845,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598616,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499061,-99) , 
4, 1.8232, 0, 0, 0.522648,-99) , 
NN(
0, 
0, 
-1, 0.585376, 0, -1, 0.427824,-99) , 
0, 0.632416, 0, 0, 0.503837,-99) , 
0, 2.55279, 0, 0, 0.51192,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0858845);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.68661,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476883,-99) , 
5, 0.387098, 0, 0, 0.576564,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5609,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496013,-99) , 
0, 0.701797, 1, 0, 0.516443,-99) , 
NN(
0, 
0, 
-1, 93.7172, 1, -1, 0.4437,-99) , 
2, 0.640199, 0, 0, 0.491357,-99) , 
2, 2.83577, 0, 0, 0.502881,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.106002);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.72278,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516662,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.391522,-99) , 
0, 1.25316, 1, 0, 0.474312,-99) , 
3, 8.02573, 0, 0, 0.544152,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554296,-99) , 
NN(
0, 
0, 
-1, 0.394555, 1, -1, 0.470748,-99) , 
5, 0.111288, 1, 0, 0.482979,-99) , 
4, 0.101093, 1, 0, 0.50198,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.110243);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630547,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635215,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485099,-99) , 
1, 208.543, 1, 0, 0.561478,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525608,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.315847,-99) , 
4, 0.810518, 1, 0, 0.506806,-99) , 
1, 23.854, 0, 0, 0.521059,-99) , 
1, 739.878, 0, 0, 0.528628,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.126597);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.664816,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600275,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489708,-99) , 
1, 151.675, 0, 0, 0.532477,-99) , 
4, 0.100684, 1, 0, 0.566766,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56576,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.386114,-99) , 
2, 2.25677, 1, 0, 0.529206,-99) , 
NN(
0, 
0, 
-1, 165.185, 1, -1, 0.463494,-99) , 
5, 0.478996, 1, 0, 0.501737,-99) , 
0, 1.50743, 0, 0, 0.51611,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.085724);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.312, 0, 1, 0.53429,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518593,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.37678,-99) , 
0, 0.566208, 0, 0, 0.478052,-99) , 
0, 0.705294, 0, 0, 0.518153,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426014,-99) , 
5, 0.1113, 0, 0, 0.5068,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0484673);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.619899,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.638551,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491954,-99) , 
5, 0.417741, 0, 0, 0.553031,-99) , 
NN(
0, 
0, 
-1, 0.135573, 0, -1, 0.490442,-99) , 
2, 2.10128, 0, 0, 0.501172,-99) , 
2, 4.07177, 0, 0, 0.507731,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.102803);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 9.28753, 0, 1, 0.54743,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55201,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429296,-99) , 
0, 1.26007, 0, 0, 0.485485,-99) , 
1, 288.231, 1, 0, 0.537238,-99) , 
NN(
0, 
0, 
-1, 0.0795771, 0, -1, 0.440272,-99) , 
5, 0.111293, 0, 0, 0.523787,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0974603);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.30599, 1, 1, 0.553223,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576151,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473809,-99) , 
5, 0.132642, 1, 0, 0.511192,-99) , 
5, 0.370286, 0, 0, 0.532157,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453934,-99) , 
5, 0.877408, 1, 0, 0.525219,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0776654);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59407,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.722686,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485773,-99) , 
3, 9.56467, 0, 0, 0.539251,-99) , 
NN(
0, 
0, 
-1, 1.87255, 1, -1, 0.477307,-99) , 
4, 0.101093, 1, 0, 0.496517,-99) , 
1, 739.878, 0, 0, 0.503241,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0797181);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.739001, 1, 1, 0.562762,-99) , 
NN(
NN(
0, 
0, 
-1, 0.277043, 0, 1, 0.516128,-99) , 
NN(
0, 
0, 
-1, 0.418937, 0, -1, 0.451508,-99) , 
5, 0.331659, 1, 0, 0.489534,-99) , 
5, 0.632213, 0, 0, 0.512235,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0581791);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59357,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51263,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437463,-99) , 
5, 0.195488, 0, 0, 0.505177,-99) , 
5, 0.139965, 1, 0, 0.516334,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441315,-99) , 
5, 0.0806526, 0, 0, 0.511844,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0964984);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.238708, 1, 1, 0.575037,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519091,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40006,-99) , 
4, 0.404184, 1, 0, 0.48773,-99) , 
5, 0.160667, 0, 0, 0.525234,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577963,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48249,-99) , 
0, 1.11594, 0, 0, 0.51746,-99) , 
NN(
0, 
0, 
-1, 0.570137, 1, -1, 0.452495,-99) , 
5, 0.636255, 0, 0, 0.481431,-99) , 
5, 0.295163, 1, 0, 0.49734,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.106724);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.651589,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513467,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427425,-99) , 
5, 0.295192, 0, 0, 0.476669,-99) , 
4, 0.0325879, 1, 0, 0.527003,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574458,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485032,-99) , 
0, 0.879068, 1, 0, 0.520719,-99) , 
NN(
0, 
0, 
-1, 0.353201, 1, -1, 0.451766,-99) , 
4, 2.05539, 0, 0, 0.472834,-99) , 
4, 0.100995, 1, 0, 0.489228,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0702477);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602266,-99) , 
NN(
NN(
0, 
0, 
-1, 3.63839, 0, 1, 0.523405,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50006,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.313672,-99) , 
5, 0.172584, 0, 0, 0.457219,-99) , 
0, 0.696259, 0, 0, 0.504516,-99) , 
3, 1112.43, 0, 0, 0.512657,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.104311);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443387,-99) , 
5, 0.174186, 0, 0, 0.519037,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518745,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42484,-99) , 
5, 0.792848, 0, 0, 0.469324,-99) , 
5, 0.598652, 1, 0, 0.498875,-99) , 
NN(
0, 
0, 
-1, 0.201443, 0, -1, 0.385093,-99) , 
5, 0.111297, 0, 0, 0.484873,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0909266);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.599545,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559708,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467443,-99) , 
4, 0.130333, 1, 0, 0.516334,-99) , 
4, 0.403695, 0, 0, 0.543145,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58051,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485312,-99) , 
0, 2.11185, 0, 0, 0.493527,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.339947,-99) , 
4, 2.72971, 1, 0, 0.4765,-99) , 
5, 0.264519, 1, 0, 0.499043,-99)    );
   return;
};

// Clean up
inline void ReadBDTh::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDTh::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}

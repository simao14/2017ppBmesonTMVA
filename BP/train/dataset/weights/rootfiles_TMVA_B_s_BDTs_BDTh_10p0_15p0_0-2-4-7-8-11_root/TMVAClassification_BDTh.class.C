// Class: ReadBDTh
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTh
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.22/01       [398849]
Creator        : tasheng
Date           : Sat Feb 25 00:07:35 2023
Host           : Linux GRENDEL01.MIT.EDU 3.10.0-957.21.3.el7.x86_64 #1 SMP Tue Jun 18 16:35:19 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/tasheng/bmva_nom/bmva_trk5/TMVA/BP/train
Training events: 44800
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "5.0%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "30" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
BaggedSampleFraction: "5.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "5.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 6
Btrk1Pt                       Btrk1Pt                       Btrk1Pt                       Btrk1Pt                                                         'F'    [0.50004953146,10.0547304153]
abs(Btrk1Dz1/Btrk1DzError1)   Trk1DCAz                      Trk1DCAz                      Trk1DCAz                                                        'F'    [0.000196472159587,7924.90039062]
abs(Btrk1Dxy1/Btrk1DxyError1) Trk1DCAxy                     Trk1DCAxy                     Trk1DCAxy                                                       'F'    [9.54853530857e-05,180.172134399]
BsvpvDistance/BsvpvDisErr     dls                           dls                           dls                                                             'F'    [2.00021791458,10266.5009766]
Balpha                        Balpha                        Balpha                        Balpha                                                          'F'    [2.49616914516e-05,3.14021730423]
Bchi2cl                       Bchi2cl                       Bchi2cl                       Bchi2cl                                                         'F'    [0.0500067919493,0.999975204468]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDThNode

#ifndef BDThNode__def
#define BDThNode__def

class BDThNode {

public:

   // constructor of an essentially "empty" node floating in space
   BDThNode ( BDThNode* left,BDThNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDThNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDThNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDThNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDThNode*   fLeft;     // pointer to the left daughter node
   BDThNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDThNode::~BDThNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDThNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] >= fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDThNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTh : public IClassifierReader {

 public:

   // constructor
   ReadBDTh( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDTh" ),
        fNvars( 6 )
   {
      // the training input variables
      const char* inputVars[] = { "Btrk1Pt", "abs(Btrk1Dz1/Btrk1DzError1)", "abs(Btrk1Dxy1/Btrk1DxyError1)", "BsvpvDistance/BsvpvDisErr", "Balpha", "Bchi2cl" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTh() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[6];
   double fVmax[6];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[6];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDThNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTh::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDThNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDThNode*)current->GetRight();
         else current=(BDThNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDTh::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(1.05643765862108);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0261056, 1, 1, 0.96808,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.800075,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427351,-99) , 
1, 217.324, 0, 0, 0.569629,-99) , 
4, 0.101115, 1, 0, 0.835213,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.942998,-99) , 
NN(
0, 
0, 
-1, 0.101461, 1, -1, 0.0905191,-99) , 
2, 3.85945, 0, 0, 0.213566,-99) , 
0, 1.41596, 0, 0, 0.493978,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.877443);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.62494, 0, 1, 0.98389,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.852829,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445751,-99) , 
4, 0.201912, 1, 0, 0.727085,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53481,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.116122,-99) , 
2, 2.06022, 0, 0, 0.191318,-99) , 
0, 1.73291, 0, 0, 0.347996,-99) , 
2, 4.91305, 0, 0, 0.521049,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.754495);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 4.84395, 0, 1, 0.849332,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.898379,-99) , 
NN(
0, 
0, 
-1, 0.101432, 1, -1, 0.215256,-99) , 
2, 4.74434, 0, 0, 0.30636,-99) , 
0, 1.70604, 0, 0, 0.51519,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.652053);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.37378, 0, 1, 0.934003,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.679023,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.281116,-99) , 
0, 0.805544, 0, 0, 0.549273,-99) , 
NN(
0, 
0, 
-1, 1.06014, 0, -1, 0.177753,-99) , 
4, 0.303942, 1, 0, 0.406714,-99) , 
2, 4.84395, 0, 0, 0.52901,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.478923);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.38222, 0, 1, 0.869524,-99) , 
NN(
NN(
0, 
0, 
-1, 2.28183, 0, 1, 0.627478,-99) , 
NN(
0, 
0, 
-1, 0.101322, 1, -1, 0.287601,-99) , 
2, 1.56299, 0, 0, 0.418435,-99) , 
2, 4.8444, 0, 0, 0.520579,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.561656);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 5.81327, 0, 1, 0.807839,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.728104,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.342622,-99) , 
4, 0.0524485, 1, 0, 0.590864,-99) , 
NN(
0, 
0, 
-1, 0.889265, 0, -1, 0.243469,-99) , 
4, 0.101496, 1, 0, 0.399507,-99) , 
0, 2.00757, 0, 0, 0.519484,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.501198);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.40296, 0, 1, 0.900676,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.946566,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459508,-99) , 
1, 3.69832, 0, 0, 0.604346,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.616616,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.273384,-99) , 
0, 2.42865, 0, 0, 0.327467,-99) , 
4, 0.101167, 1, 0, 0.43722,-99) , 
2, 4.91334, 0, 0, 0.52815,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.444597);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.1168, 0, 1, 0.879849,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.700476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.410744,-99) , 
5, 0.478991, 0, 0, 0.539151,-99) , 
4, 0.0359757, 1, 0, 0.719681,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.806685,-99) , 
NN(
0, 
0, 
-1, 1.06014, 0, -1, 0.361882,-99) , 
2, 3.85973, 0, 0, 0.414073,-99) , 
4, 0.101349, 1, 0, 0.557219,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.366984);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.90542, 0, 1, 0.95024,-99) , 
NN(
NN(
0, 
0, 
-1, 2.62531, 0, 1, 0.613202,-99) , 
NN(
0, 
0, 
-1, 0.202647, 1, -1, 0.355184,-99) , 
0, 1.11671, 0, 0, 0.485706,-99) , 
2, 5.81241, 0, 0, 0.55342,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.337875);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.94355, 0, 1, 0.856293,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607591,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431624,-99) , 
4, 0.404934, 1, 0, 0.552749,-99) , 
2, 4.25731, 0, 0, 0.614417,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.636122,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.275261,-99) , 
0, 2.04134, 0, 0, 0.350226,-99) , 
5, 0.203227, 0, 0, 0.548719,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.265722);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.70364, 0, 1, 0.816011,-99) , 
NN(
NN(
0, 
0, 
-1, 0.38744, 0, 1, 0.750977,-99) , 
NN(
0, 
0, 
-1, 0.172627, 0, -1, 0.433474,-99) , 
2, 2.69407, 0, 0, 0.479438,-99) , 
2, 4.91319, 0, 0, 0.534719,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.302152);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.00465, 0, 1, 0.93295,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.686898,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481611,-99) , 
4, 0.101508, 1, 0, 0.561784,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.304751,-99) , 
5, 0.141936, 0, 0, 0.513289,-99) , 
2, 5.8121, 0, 0, 0.566406,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.280114);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 4.91274, 0, 1, 0.626988,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.279539,-99) , 
4, 2.63374, 1, 0, 0.591612,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.260375);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.92959, 0, 1, 0.823385,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.634656,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464082,-99) , 
2, 1.40686, 0, 0, 0.537815,-99) , 
2, 4.84455, 0, 0, 0.590065,-99) , 
NN(
0, 
0, 
-1, 0.101502, 1, -1, 0.361996,-99) , 
0, 0.805321, 0, 0, 0.528634,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.274044);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.387086, 0, 1, 0.871732,-99) , 
NN(
NN(
0, 
0, 
-1, 2.50042, 0, 1, 0.575742,-99) , 
NN(
0, 
0, 
-1, 2.30413, 0, -1, 0.37129,-99) , 
5, 0.325797, 0, 0, 0.495262,-99) , 
2, 4.8444, 0, 0, 0.546025,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.30442);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.509668, 1, 1, 0.813049,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.666511,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460289,-99) , 
0, 0.768484, 0, 0, 0.598266,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.707851,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.386589,-99) , 
2, 3.90147, 0, 0, 0.428374,-99) , 
5, 0.479013, 0, 0, 0.507431,-99) , 
0, 3.274, 0, 0, 0.544054,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.204183);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.929068,-99) , 
NN(
NN(
0, 
0, 
-1, 1.12456, 0, 1, 0.701166,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543802,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.388576,-99) , 
4, 0.708218, 1, 0, 0.505163,-99) , 
0, 2.90541, 0, 0, 0.533675,-99) , 
2, 11.6247, 0, 0, 0.555966,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.144639);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.66352, 0, 1, 0.773285,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.738572,-99) , 
NN(
0, 
0, 
-1, 0.322673, 0, -1, 0.470437,-99) , 
2, 3.32844, 0, 0, 0.489676,-99) , 
2, 4.91334, 0, 0, 0.523477,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.205696);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 4.04712, 1, 1, 0.74545,-99) , 
NN(
NN(
0, 
0, 
-1, 3.95302, 0, 1, 0.565085,-99) , 
NN(
0, 
0, 
-1, 0.101348, 1, -1, 0.395038,-99) , 
5, 0.203228, 0, 0, 0.520175,-99) , 
0, 2.92312, 0, 0, 0.554404,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.158193);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.990671,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453004,-99) , 
0, 1.70464, 0, 0, 0.704567,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.74542,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492506,-99) , 
2, 2.69452, 0, 0, 0.523772,-99) , 
2, 4.91319, 0, 0, 0.547444,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.291175,-99) , 
4, 2.62798, 1, 0, 0.524153,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.158575);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.70377, 0, 1, 0.776758,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.705349,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.623635,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469771,-99) , 
0, 3.2742, 0, 0, 0.48438,-99) , 
2, 3.16867, 0, 0, 0.502404,-99) , 
2, 4.91319, 0, 0, 0.534199,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.175304);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.931002,-99) , 
NN(
NN(
0, 
0, 
-1, 4.11789, 0, 1, 0.553317,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.341702,-99) , 
5, 0.111298, 0, 0, 0.526589,-99) , 
2, 9.82569, 0, 0, 0.548992,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.159308);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 4.79591, 1, 1, 0.755052,-99) , 
NN(
NN(
0, 
0, 
-1, 4.91274, 0, 1, 0.532639,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.360084,-99) , 
0, 0.659134, 0, 0, 0.501487,-99) , 
0, 2.96579, 0, 0, 0.53518,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.189431);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.791991,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.638351,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480291,-99) , 
5, 0.325803, 0, 0, 0.574588,-99) , 
NN(
0, 
0, 
-1, 0.306742, 0, -1, 0.434554,-99) , 
2, 0.950728, 0, 0, 0.51532,-99) , 
2, 9.82539, 0, 0, 0.533202,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.143811);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.100267, 1, 1, 0.652289,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512392,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.385355,-99) , 
0, 1.66404, 1, 0, 0.495551,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.322218,-99) , 
4, 2.02307, 1, 0, 0.472103,-99) , 
0, 2.00359, 0, 0, 0.514555,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.230632);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.1007, 1, 1, 0.751687,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.753283,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490698,-99) , 
4, 0.0262298, 1, 0, 0.540073,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578453,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.289272,-99) , 
3, 278.361, 0, 0, 0.406466,-99) , 
4, 0.202557, 1, 0, 0.489696,-99) , 
0, 2.94207, 0, 0, 0.522342,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.236877);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.85965,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.782627,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456201,-99) , 
3, 9.00072, 0, 0, 0.56581,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558248,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399482,-99) , 
3, 284.158, 0, 0, 0.444711,-99) , 
4, 0.101275, 1, 0, 0.493245,-99) , 
2, 9.48782, 0, 0, 0.512584,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.204153);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.850466,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.41203,-99) , 
4, 1.92022, 1, 0, 0.550998,-99) , 
NN(
0, 
0, 
-1, 0.386999, 0, -1, 0.404698,-99) , 
0, 0.798321, 0, 0, 0.505311,-99) , 
0, 3.5822, 0, 0, 0.528853,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.159856);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.753815,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.640829,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425609,-99) , 
5, 0.930664, 0, 0, 0.526277,-99) , 
5, 0.873489, 1, 0, 0.618023,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.648124,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516445,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417933,-99) , 
4, 0.202627, 1, 0, 0.478362,-99) , 
0, 2.91187, 0, 0, 0.499334,-99) , 
5, 0.754823, 0, 0, 0.525481,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.128036);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.697419,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.605847,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482233,-99) , 
4, 0.101341, 1, 0, 0.534689,-99) , 
NN(
0, 
0, 
-1, 0.973, 0, -1, 0.44426,-99) , 
5, 0.264517, 0, 0, 0.505403,-99) , 
0, 4.16309, 0, 0, 0.516665,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.17576);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.815445,-99) , 
NN(
NN(
0, 
0, 
-1, 0.0195811, 1, 1, 0.541132,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.595342,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.246623,-99) , 
1, 187.707, 0, 0, 0.406531,-99) , 
4, 0.607373, 1, 0, 0.510656,-99) , 
0, 3.84197, 0, 0, 0.528499,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.146477);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.100686, 1, 1, 0.657796,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542348,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424112,-99) , 
0, 1.68315, 1, 0, 0.51454,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4016,-99) , 
5, 0.141939, 0, 0, 0.49493,-99) , 
0, 2.65756, 0, 0, 0.518114,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.112836);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0109576, 1, 1, 0.56875,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523633,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.411675,-99) , 
0, 2.00762, 1, 0, 0.491862,-99) , 
4, 0.0847809, 1, 0, 0.522312,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409253,-99) , 
4, 2.62775, 1, 0, 0.511673,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.117351);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.803357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499406,-99) , 
2, 3.902, 0, 0, 0.5562,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52359,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.231935,-99) , 
2, 6.21189, 1, 0, 0.493814,-99) , 
0, 1.40392, 0, 0, 0.51863,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372483,-99) , 
4, 2.63301, 1, 0, 0.506188,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.156105);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 5.8121, 0, 1, 0.579265,-99) , 
NN(
0, 
0, 
-1, 0.63719, 0, -1, 0.424575,-99) , 
0, 1.10767, 0, 0, 0.505103,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.1292);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.0998578, 1, 1, 0.611673,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581145,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468165,-99) , 
3, 278.541, 0, 0, 0.486719,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.366031,-99) , 
0, 0.659115, 0, 0, 0.464548,-99) , 
0, 2.96577, 0, 0, 0.483554,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0939303);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.52284, 0, 1, 0.528253,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372513,-99) , 
4, 2.53245, 1, 0, 0.513096,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.351125,-99) , 
0, 4.41916, 1, 0, 0.500081,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.191544);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.749996,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558099,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417085,-99) , 
0, 1.72128, 1, 0, 0.514824,-99) , 
NN(
0, 
0, 
-1, 240.295, 0, -1, 0.394491,-99) , 
4, 0.303283, 1, 0, 0.476058,-99) , 
2, 4.39357, 0, 0, 0.501753,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.104727);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.689013,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.597735,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490436,-99) , 
5, 0.754796, 0, 0, 0.509877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.381426,-99) , 
2, 0.316838, 0, 0, 0.491704,-99) , 
2, 4.91274, 0, 0, 0.509388,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.135059);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.799115,-99) , 
NN(
NN(
0, 
0, 
-1, 0.857601, 1, 1, 0.622503,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.580085,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469798,-99) , 
3, 664.227, 0, 0, 0.484578,-99) , 
5, 0.754798, 0, 0, 0.510711,-99) , 
0, 3.85783, 0, 0, 0.527138,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.147995);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.737315,-99) , 
NN(
NN(
0, 
0, 
-1, 0.41795, 0, 1, 0.690193,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585565,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474729,-99) , 
5, 0.233861, 1, 0, 0.506565,-99) , 
2, 2.69401, 0, 0, 0.527012,-99) , 
2, 4.91305, 0, 0, 0.544041,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.113816);
  fForest.push_back( 
NN(
0, 
0, 
-1, 4.91274, 0, 1, 0.556663,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.111561);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.716676,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481834,-99) , 
4, 0.100961, 1, 0, 0.508686,-99) , 
2, 5.8121, 0, 0, 0.526768,-99) , 
NN(
0, 
0, 
-1, 0.101567, 1, -1, 0.426143,-99) , 
0, 0.80387, 0, 0, 0.498769,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.128639);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.52938, 0, 1, 0.604648,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497932,-99) , 
5, 0.203226, 0, 0, 0.576301,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512301,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412934,-99) , 
4, 0.202798, 1, 0, 0.474453,-99) , 
NN(
0, 
0, 
-1, 0.387324, 0, -1, 0.357846,-99) , 
2, 3.26861, 1, 0, 0.454268,-99) , 
0, 1.73291, 0, 0, 0.490357,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.130608);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.387048, 0, 1, 0.6073,-99) , 
NN(
0, 
0, 
-1, 4.74434, 1, -1, 0.451523,-99) , 
0, 1.70303, 0, 0, 0.495109,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.155624);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578282,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478927,-99) , 
5, 0.81609, 1, 0, 0.561496,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.380444,-99) , 
0, 0.647282, 0, 0, 0.534056,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40713,-99) , 
0, 5.0572, 1, 0, 0.527511,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.142766);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.738616,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60412,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490201,-99) , 
5, 0.54032, 0, 0, 0.535448,-99) , 
NN(
0, 
0, 
-1, 0.69345, 1, -1, 0.430238,-99) , 
2, 1.12524, 0, 0, 0.482067,-99) , 
2, 5.81254, 0, 0, 0.499496,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.159521);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.78292, 1, 1, 0.635048,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.580259,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480394,-99) , 
0, 1.66502, 1, 0, 0.547119,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417865,-99) , 
5, 0.662709, 0, 0, 0.464357,-99) , 
0, 0.969028, 0, 0, 0.50689,-99) , 
0, 2.31734, 0, 0, 0.530286,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.10145);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.780016,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.68051,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48682,-99) , 
2, 2.96978, 0, 0, 0.503727,-99) , 
2, 4.84482, 0, 0, 0.524462,-99) , 
NN(
0, 
0, 
-1, 0.0974546, 1, -1, 0.433512,-99) , 
5, 0.14195, 0, 0, 0.506814,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.365006);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.80173, 0, 1, 0.604694,-99) , 
NN(
NN(
0, 
0, 
-1, 1.1168, 0, 1, 0.68111,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.62016,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.208007,-99) , 
3, 2.87941, 0, 0, 0.451071,-99) , 
3, 11.0909, 0, 0, 0.50856,-99) , 
3, 284.158, 0, 0, 0.524045,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.137882);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.386093, 0, 1, 0.600404,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.637307,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.30887,-99) , 
5, 0.782611, 0, 0, 0.477575,-99) , 
5, 0.662878, 1, 0, 0.556929,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519945,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403954,-99) , 
2, 2.01208, 1, 0, 0.491889,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.381325,-99) , 
2, 3.90178, 1, 0, 0.480804,-99) , 
0, 1.71555, 0, 0, 0.502847,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.107301);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.761235,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.648001,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488989,-99) , 
0, 2.00664, 0, 0, 0.515153,-99) , 
NN(
0, 
0, 
-1, 0.419159, 0, -1, 0.45376,-99) , 
2, 0.764946, 0, 0, 0.492508,-99) , 
2, 4.74374, 0, 0, 0.510842,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.134928);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.643446,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446524,-99) , 
0, 1.10597, 1, 0, 0.481343,-99) , 
5, 0.877371, 0, 0, 0.499592,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.601578,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.196754,-99) , 
0, 1.36566, 0, 0, 0.373093,-99) , 
2, 5.81254, 1, 0, 0.486181,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.146275);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.98166, 1, 1, 0.614128,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420849,-99) , 
5, 0.841801, 0, 0, 0.469501,-99) , 
5, 0.509681, 1, 0, 0.546174,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.620159,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479436,-99) , 
1, 4.18399, 0, 0, 0.510031,-99) , 
NN(
0, 
0, 
-1, 0.356536, 1, -1, 0.437494,-99) , 
4, 0.10146, 1, 0, 0.470058,-99) , 
0, 1.42471, 0, 0, 0.501752,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.116309);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.654923,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.643646,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475808,-99) , 
4, 0.0294022, 1, 0, 0.500499,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524941,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.359755,-99) , 
3, 664.227, 0, 0, 0.431793,-99) , 
4, 0.911045, 1, 0, 0.485668,-99) , 
0, 3.84187, 0, 0, 0.495098,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.124202);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.935734, 1, 1, 0.637491,-99) , 
NN(
NN(
0, 
0, 
-1, 0.60957, 0, 1, 0.54039,-99) , 
NN(
0, 
0, 
-1, 2.30907, 1, -1, 0.40161,-99) , 
5, 0.692495, 1, 0, 0.512383,-99) , 
5, 0.846729, 0, 0, 0.526577,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.122867);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.696289,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586624,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468795,-99) , 
0, 1.37346, 0, 0, 0.509823,-99) , 
NN(
0, 
0, 
-1, 0.59964, 0, -1, 0.445464,-99) , 
5, 0.172593, 1, 0, 0.458254,-99) , 
0, 3.89042, 0, 0, 0.470597,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.121333);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.655835,-99) , 
NN(
NN(
0, 
0, 
-1, 1.29519, 0, 1, 0.529873,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586043,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.39514,-99) , 
0, 3.61238, 0, 0, 0.43138,-99) , 
0, 1.73291, 1, 0, 0.49818,-99) , 
2, 4.91274, 0, 0, 0.509688,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.133942);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.814849, 1, 1, 0.595951,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497421,-99) , 
5, 0.739047, 0, 0, 0.56928,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563703,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452249,-99) , 
5, 0.330053, 1, 0, 0.509489,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.353586,-99) , 
5, 0.0895459, 0, 0, 0.494034,-99) , 
5, 0.662869, 0, 0, 0.515718,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.146158);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.871898,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496269,-99) , 
4, 0.0195775, 1, 0, 0.576083,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.377001,-99) , 
0, 3.35034, 1, 0, 0.519652,-99) , 
4, 0.101174, 1, 0, 0.53994,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537471,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.349662,-99) , 
0, 0.629492, 0, 0, 0.452044,-99) , 
0, 0.808509, 0, 0, 0.512775,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0909149);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.654224,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.631854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488544,-99) , 
2, 2.607, 0, 0, 0.503532,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50289,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389115,-99) , 
5, 0.66279, 0, 0, 0.422448,-99) , 
0, 2.31749, 1, 0, 0.48704,-99) , 
2, 4.25678, 0, 0, 0.501178,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.106839);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.325799, 1, 1, 0.554259,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520629,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469793,-99) , 
0, 0.646874, 0, 0, 0.491172,-99) , 
0, 0.803851, 0, 0, 0.533718,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.364561,-99) , 
4, 2.53175, 1, 0, 0.518546,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.1475);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.662694,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.388614,-99) , 
2, 3.52223, 1, 0, 0.530585,-99) , 
4, 0.0196184, 1, 0, 0.544907,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.369078,-99) , 
3, 284.16, 0, 0, 0.47555,-99) , 
4, 0.606954, 1, 0, 0.52878,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.146016);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581737,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477035,-99) , 
5, 0.448365, 0, 0, 0.525905,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529575,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400278,-99) , 
5, 0.417727, 1, 0, 0.465268,-99) , 
2, 0.93742, 0, 0, 0.50056,-99) , 
NN(
0, 
0, 
-1, 1.07829, 0, -1, 0.305702,-99) , 
2, 5.8121, 1, 0, 0.477665,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.103363);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.633474,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534593,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469364,-99) , 
5, 0.280335, 1, 0, 0.482637,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407567,-99) , 
5, 0.141944, 0, 0, 0.468579,-99) , 
0, 2.96577, 0, 0, 0.484293,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.112277);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565641,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401368,-99) , 
0, 1.9767, 1, 0, 0.529043,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567699,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460432,-99) , 
1, 162.644, 0, 0, 0.474544,-99) , 
5, 0.662876, 0, 0, 0.49077,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407045,-99) , 
0, 3.55258, 1, 0, 0.483009,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.111687);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.627062,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588781,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471143,-99) , 
4, 0.39399, 0, 0, 0.526379,-99) , 
4, 0.100932, 1, 0, 0.560102,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463858,-99) , 
5, 0.35647, 0, 0, 0.5038,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.394228,-99) , 
0, 1.47684, 1, 0, 0.48976,-99) , 
0, 1.71158, 0, 0, 0.509755,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0733912);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593019,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.610966,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.595328,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492777,-99) , 
1, 12.8809, 0, 0, 0.510292,-99) , 
1, 399.43, 0, 0, 0.518965,-99) , 
5, 0.111293, 1, 0, 0.526848,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.126271);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.01921, 0, 1, 0.538522,-99) , 
NN(
0, 
0, 
-1, 0.90665, 0, -1, 0.439928,-99) , 
5, 0.847716, 1, 0, 0.518344,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546317,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40381,-99) , 
4, 0.202834, 1, 0, 0.487563,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.254881,-99) , 
2, 4.91274, 1, 0, 0.452691,-99) , 
5, 0.325793, 0, 0, 0.492593,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.137318);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.101115, 1, 1, 0.623379,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478924,-99) , 
5, 0.264708, 0, 0, 0.572191,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505982,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.351159,-99) , 
4, 0.506704, 1, 0, 0.471543,-99) , 
NN(
0, 
0, 
-1, 0.356685, 0, -1, 0.304797,-99) , 
2, 3.902, 1, 0, 0.446708,-99) , 
0, 1.72122, 0, 0, 0.480704,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0862444);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.657463,-99) , 
NN(
NN(
0, 
0, 
-1, 2.62481, 0, 1, 0.529624,-99) , 
NN(
0, 
0, 
-1, 2.34955, 1, -1, 0.458228,-99) , 
5, 0.356441, 0, 0, 0.49637,-99) , 
2, 5.81263, 0, 0, 0.506566,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.103968);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.592695,-99) , 
NN(
NN(
0, 
0, 
-1, 2.97419, 0, 1, 0.519983,-99) , 
NN(
0, 
0, 
-1, 1.11117, 0, -1, 0.412048,-99) , 
2, 0.86984, 0, 0, 0.475768,-99) , 
2, 4.49919, 0, 0, 0.486118,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.10037);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.620288,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584687,-99) , 
NN(
0, 
0, 
-1, 2.18288, 1, -1, 0.457502,-99) , 
2, 3.56193, 0, 0, 0.465231,-99) , 
2, 5.8121, 0, 0, 0.475445,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.115659);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.417799, 0, 1, 0.621536,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59067,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443541,-99) , 
0, 0.891936, 0, 0, 0.528922,-99) , 
NN(
0, 
0, 
-1, 0.521565, 0, -1, 0.46636,-99) , 
5, 0.32583, 1, 0, 0.490597,-99) , 
0, 2.93046, 0, 0, 0.504177,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0906877);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.687196,-99) , 
NN(
NN(
0, 
0, 
-1, 0.35689, 0, 1, 0.58459,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513313,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373044,-99) , 
2, 2.08621, 1, 0, 0.492241,-99) , 
2, 2.81278, 0, 0, 0.502757,-99) , 
2, 5.81263, 0, 0, 0.513364,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.123601);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.675078,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.604926,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464324,-99) , 
2, 2.66635, 0, 0, 0.476511,-99) , 
2, 3.93845, 0, 0, 0.493832,-99) , 
NN(
0, 
0, 
-1, 2.34934, 1, -1, 0.414332,-99) , 
5, 0.20322, 0, 0, 0.473748,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.131041);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.639721,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.596356,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489297,-99) , 
4, 0.10101, 1, 0, 0.535335,-99) , 
5, 0.209154, 0, 0, 0.562988,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.38935,-99) , 
4, 0.908863, 1, 0, 0.494728,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518429,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.354631,-99) , 
4, 0.10093, 0, 0, 0.432885,-99) , 
5, 0.691577, 1, 0, 0.46918,-99) , 
5, 0.264523, 1, 0, 0.500264,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0858499);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.10109, 1, 1, 0.548752,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546041,-99) , 
NN(
0, 
0, 
-1, 0.654679, 1, -1, 0.459051,-99) , 
5, 0.919909, 0, 0, 0.465463,-99) , 
5, 0.172593, 1, 0, 0.482232,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.096651);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 4.05787, 1, 1, 0.614674,-99) , 
NN(
NN(
0, 
0, 
-1, 1.33472, 0, 1, 0.528231,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545362,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.371351,-99) , 
5, 0.295175, 0, 0, 0.472616,-99) , 
0, 1.67617, 1, 0, 0.515509,-99) , 
0, 2.93065, 0, 0, 0.526231,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.110767);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.659001,-99) , 
NN(
NN(
0, 
0, 
-1, 3.48132, 1, 1, 0.587425,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515118,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436416,-99) , 
5, 0.387023, 1, 0, 0.470606,-99) , 
2, 2.69401, 0, 0, 0.484362,-99) , 
2, 4.91305, 0, 0, 0.495894,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.121964);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.61237, 1, 1, 0.569725,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529007,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456127,-99) , 
5, 0.572972, 0, 0, 0.48987,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372461,-99) , 
5, 0.172589, 0, 0, 0.463762,-99) , 
0, 1.73313, 0, 0, 0.49367,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.112489);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635993,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537741,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489717,-99) , 
4, 0.685238, 1, 0, 0.518472,-99) , 
4, 0.100763, 1, 0, 0.561336,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567256,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470279,-99) , 
0, 0.897476, 1, 0, 0.520706,-99) , 
NN(
0, 
0, 
-1, 0.27537, 1, -1, 0.444678,-99) , 
5, 0.632217, 0, 0, 0.469413,-99) , 
0, 2.04127, 0, 0, 0.487924,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.128914);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.200425, 1, 1, 0.621667,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469072,-99) , 
0, 1.59309, 0, 0, 0.486944,-99) , 
0, 2.04113, 0, 0, 0.513069,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535782,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440684,-99) , 
0, 1.41224, 0, 0, 0.476604,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.355739,-99) , 
5, 0.822122, 0, 0, 0.425767,-99) , 
5, 0.724202, 1, 0, 0.491154,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.111162);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542992,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488351,-99) , 
2, 0.80535, 0, 0, 0.521944,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.364222,-99) , 
2, 3.56876, 1, 0, 0.500877,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529501,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40757,-99) , 
0, 2.23091, 0, 0, 0.480111,-99) , 
NN(
0, 
0, 
-1, 0.742964, 0, -1, 0.382479,-99) , 
5, 0.60158, 1, 0, 0.439628,-99) , 
0, 1.7059, 1, 0, 0.483132,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.107663);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.646774,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572476,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526107,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423329,-99) , 
4, 0.176423, 1, 0, 0.49534,-99) , 
4, 1.82337, 0, 0, 0.508405,-99) , 
5, 0.908044, 0, 0, 0.518193,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.125451);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603569,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.651389,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49294,-99) , 
4, 0.0152023, 1, 0, 0.53404,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51885,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403636,-99) , 
4, 0.172361, 0, 0, 0.458492,-99) , 
4, 0.0587512, 1, 0, 0.483033,-99) , 
4, 1.82337, 0, 0, 0.502234,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.106254);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.90584, 0, 1, 0.536285,-99) , 
NN(
0, 
0, 
-1, 0.101194, 0, -1, 0.405899,-99) , 
5, 0.724178, 1, 0, 0.498751,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0714889);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.751123, 0, 1, 0.511569,-99) , 
NN(
0, 
0, 
-1, 0.891486, 0, -1, 0.430408,-99) , 
5, 0.813118, 1, 0, 0.495045,-99) , 
NN(
0, 
0, 
-1, 0.125127, 1, -1, 0.41498,-99) , 
5, 0.172589, 0, 0, 0.479066,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.128202);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.78137,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551138,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.376749,-99) , 
0, 1.49423, 1, 0, 0.521629,-99) , 
0, 2.04114, 0, 0, 0.555383,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549558,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478454,-99) , 
5, 0.662735, 0, 0, 0.496995,-99) , 
NN(
0, 
0, 
-1, 0.448742, 0, -1, 0.401919,-99) , 
0, 2.16054, 1, 0, 0.475638,-99) , 
4, 0.101321, 1, 0, 0.508281,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0922307);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.627567,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.66041,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494254,-99) , 
4, 0.0261603, 1, 0, 0.515015,-99) , 
NN(
0, 
0, 
-1, 241.977, 0, -1, 0.437817,-99) , 
4, 0.202121, 1, 0, 0.483515,-99) , 
2, 4.91334, 0, 0, 0.493031,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.108438);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577571,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462783,-99) , 
5, 0.509277, 1, 0, 0.527301,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515619,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443137,-99) , 
4, 0.0587294, 1, 0, 0.469344,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.336257,-99) , 
2, 8.51389, 1, 0, 0.458715,-99) , 
4, 0.303687, 0, 0, 0.478157,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.119505);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.216151, 1, 1, 0.616738,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541801,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458882,-99) , 
5, 0.0920918, 1, 0, 0.49639,-99) , 
5, 0.158744, 0, 0, 0.561624,-99) , 
NN(
NN(
0, 
0, 
-1, 2.63683, 0, 1, 0.523519,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.337823,-99) , 
5, 0.418793, 0, 0, 0.498395,-99) , 
5, 0.356444, 1, 0, 0.525589,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0929343);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.658128,-99) , 
NN(
NN(
0, 
0, 
-1, 0.100952, 1, 1, 0.572056,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51461,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453236,-99) , 
5, 0.509656, 1, 0, 0.485842,-99) , 
2, 2.14156, 0, 0, 0.503919,-99) , 
2, 4.74374, 0, 0, 0.513938,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0982594);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0684343, 1, 1, 0.553126,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487279,-99) , 
0, 0.803175, 0, 0, 0.531857,-99) , 
NN(
0, 
0, 
-1, 284.16, 0, -1, 0.417154,-99) , 
4, 0.707488, 1, 0, 0.507995,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.129368);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.675208,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57938,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389827,-99) , 
5, 0.920273, 0, 0, 0.492393,-99) , 
5, 0.85466, 1, 0, 0.553171,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589442,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466713,-99) , 
0, 1.2585, 0, 0, 0.506935,-99) , 
NN(
0, 
0, 
-1, 0.524594, 1, -1, 0.443234,-99) , 
0, 2.30902, 1, 0, 0.494903,-99) , 
5, 0.785441, 0, 0, 0.504905,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.123976);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.210152, 1, 1, 0.559887,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.666961,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465511,-99) , 
3, 15.0782, 0, 0, 0.499952,-99) , 
4, 0.114274, 0, 0, 0.525804,-99) , 
NN(
0, 
0, 
-1, 280.539, 0, -1, 0.425284,-99) , 
4, 0.708904, 1, 0, 0.505268,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.109513);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624649,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459284,-99) , 
0, 0.848247, 0, 0, 0.50357,-99) , 
5, 0.141944, 1, 0, 0.526517,-99) , 
NN(
0, 
0, 
-1, 0.387051, 0, -1, 0.42572,-99) , 
0, 2.65769, 1, 0, 0.510766,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.140249);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593451,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531599,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453794,-99) , 
5, 0.448212, 0, 0, 0.493464,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.384994,-99) , 
3, 15.0772, 0, 0, 0.415652,-99) , 
4, 0.101416, 0, 0, 0.458736,-99) , 
0, 2.94207, 0, 0, 0.4705,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.137807);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.743097,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555411,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454966,-99) , 
4, 0.202318, 1, 0, 0.515733,-99) , 
0, 2.6103, 0, 0, 0.539802,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553973,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442698,-99) , 
0, 0.839467, 0, 0, 0.50526,-99) , 
NN(
0, 
0, 
-1, 2.76073, 0, -1, 0.40609,-99) , 
0, 2.0035, 1, 0, 0.480736,-99) , 
5, 0.387089, 0, 0, 0.511953,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.139704);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.626373,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486023,-99) , 
4, 0.101628, 1, 0, 0.554466,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573348,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.665008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448313,-99) , 
1, 7.58355, 0, 0, 0.481448,-99) , 
1, 235.945, 0, 0, 0.495627,-99) , 
0, 0.80295, 1, 0, 0.514178,-99)    );
   return;
};

// Clean up
inline void ReadBDTh::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDTh::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}
